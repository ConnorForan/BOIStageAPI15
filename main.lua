local mod = RegisterMod("StageAPI", 1)

--[[ FUNCTIONALITY

- RoomsList - object containing room filenames and the require()d files.
-- RoomsList(roomfile, roomfile, roomfile)

- Backdrop - object containing backdrop filenames (not a real object, just a way of setting a table up that you need to do)
{
    NFloors = {file},
    LFloors = {file, file},
    Corners = {file},
    Walls = {file, file, file}
}

- Grids - object containing grid filenames
-- SetRocks(filename)
-- SetBridges(filename)
-- SetPits(filename)
-- SetDecorations(filename)
-- SetDoors(filename, targetType, currentType, targetNot, currentNot) -- target / current type can be nil for any

- RoomGfx - object containing Backdrop & Grid Entity gfx.
-- RoomGfx(backdrop, grids)
-- SetRoomGfx(RoomGfx) -- loads all grids & backdrop
-- Can be assigned to RoomTypes as well, for boss rooms, challenge rooms, etc. Assign multiple for random choice.

- CustomStage
-- SetRoomGfx(RoomGfx, RoomType)
-- SetRoomMusic(Music, RoomType)
-- SetRooms(RoomsList)
-- SetEndStage(stage, custom) -- where this stage will output you, "stage" can be a CustomStage or a LevelStage, interpretation based on "custom" bool. This is to be used for multi stage floors.
-- SetName(name) -- string that is automatically rendered on stage enter, like "Glacier 1" or "Glacer 2"
-- Duplicate() -- clones the stage. Useful for multi stage floors, to duplicate, make changes, then pass into SetEndStage of the first.
-- SetBosses(bosses)

- Bosses - object containing boss information (not a real object, just a way of setting a table up that you need to do)
{
    {
        Name = "", -- Used for identification
        Portrait = "",
        Bossname = "",
        Rooms = RoomsList,
        Shapes = {RoomShape, RoomShape}, -- optional, autogenerated from list if not specified,
        IsDoubleTrouble = false,
        Portrait2 = "", -- used for double trouble
        Weight = 1,
        Horseman = false -- in boss selection, if a horseman boss already exists in the boss room and there is a boss for the floor with the Horseman flag set, picks that boss.
    },
    ...
}

- CustomRoom (mostly internal class, but accessible)
-- Name
-- Filename
-- Layout
-- RoomGfx
-- ListIndex
-- IsCleared
-- Load(doEnemies, doGrids)
-- TypeOverride -- Not normally set, can be to change how Grid, Backdrop, and Music work.

- Basic Internal
-- Class(Type) -- returns an object that can be called with () to instantiate an object with metatable __index set to the original, then calling functions named init.
-- AddCallback(id, priority, fn, ...) -- higher priority = sooner
--- PRE_ROOM_SELECT(rooms) -- return room to force it to spawn and cancel other callbacks, doesn't have to be one of the rooms the api is choosing
--- PRE_ROOM_LOAD(layout, doEnemies, doGrids) -- return false to cancel other callbacks and prevent layout from spawning
--- PRE_ROOM_GRAPHICS_LOAD() -- return false to cancel other callbacks and prevent graphics from loading
--- POST_ROOM_LOAD()
--- PRE_ROOM_ENTER(reentered) -- called when entering room, before selection, load, gfx, etc. Return false to cancel all load. Good for custom special rooms that shouldn't act the same way as the floor.
--- POST_ROOM_ENTER(reentered) -- called when entering room, after selection, load, gfx
--- PRE_SPAWN_ENTRY(entry, isGrid) -- return false or a new entry to cancel / change
--- POST_SPAWN_ENTRY(spawned, isGrid, entry)
--- PRE_BOSS_SELECT(bosses) -- return boss to force it to spawn and cancel other callbacks, doesn't have to be one of the rooms the api is choosing
--- PRE_BOSS_ANIMATION_PLAY(name, portrait, bossname) -- return false or new name, portrait, and bossname to cancel / change

- Basic External
-- SetCustomStage(CustomStage) -- go to a custom stage
-- ChangeGrids(grids)
-- ChangeBackdrop(backdrop[s]) -- if multiple backdrops are passed in a table, select a random "variant". nfloors, walls, etc selected at random from that variant's lists.
-- ChangeRoomLayout(RoomsList)
-- GetCurrentRoom()
-- GetRoomAtListIndex(listindex)
]]

if not StageAPI then
    StageAPI = {}
end

setmetatable(StageAPI, {
    __index = function(tbl, ind)
        if ind == "Room" then
            tbl.Room = tbl.Game:GetRoom()
            return tbl.Room
        elseif ind == "Level" then
            tbl.Level = tbl.Game:GetLevel()
            return tbl.Level
        end
    end
})

StageAPI.Game = Game()
StageAPI.Players = {}

if Isaac.GetPlayer(0) then
    StageAPI.Room = StageAPI.Game:GetRoom()
    StageAPI.Level = StageAPI.Game:GetLevel()
    local numPlayers = StageAPI.Game:GetNumPlayers()
    if numPlayers > 0 then
        for i = 1, numPlayers do
            StageAPI.Players[i] = Isaac.GetPlayer(i - 1)
        end
    end
end

StageAPI.ZeroVector = Vector(0, 0)

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, function()
    StageAPI.Level = StageAPI.Game:GetLevel()
    StageAPI.Room = StageAPI.Game:GetRoom()
    for i = 1, StageAPI.Game:GetNumPlayers() do
        StageAPI.Players[i] = Isaac.GetPlayer(i - 1)
    end
end)


mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
    StageAPI.Level = StageAPI.Game:GetLevel()
    StageAPI.Room = StageAPI.Game:GetRoom()
end)

local game, room, level, players, zeroVector = StageAPI.Game, StageAPI.Room, StageAPI.Level, StageAPI.Players, StageAPI.ZeroVector

mod:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, function(_, shouldSave)
    StageAPI.Players = {}
end)

StageAPI.E = {
    Backdrop = "StageAPIBackdrop",
    Bridge = "StageAPIBridge",
    Shading = "StageAPIShading"
}

for k, v in pairs(StageAPI.E) do
    StageAPI.E[k] = {
        T = Isaac.GetEntityTypeByName(v),
        V = Isaac.GetEntityVariantByName(v)
    }
end

StageAPI.RandomRNG = RNG()
StageAPI.RandomRNG:SetSeed(Random(), 0)
function StageAPI.Random(min, max, rng)
    rng = rng or StageAPI.RandomRNG
    if min and max then
        return math.floor(rng:RandomFloat() * (max - min + 1) + min)
    elseif min ~= nil then
        return math.floor(rng:RandomFloat() * (min + 1))
    end
    return rng:RandomFloat()
end

function StageAPI.WeightedRNG(args, rng, key) -- takes tables {{obj, weight}, {"pie", 3}, {555, 0}}
    local weight_value = 0
    local iterated_weight = 1
    for _, potentialObject in ipairs(args) do
        if key then
            weight_value = weight_value + potentialObject[key]
        else
            weight_value = weight_value + potentialObject[2]
        end
    end

    local random_chance = StageAPI.Random(1, weight_value, rng)
    for i, potentialObject in ipairs(args) do
        if key then
            iterated_weight = iterated_weight + potentialObject[key]
        else
            iterated_weight = iterated_weight + potentialObject[2]
        end

        if iterated_weight > random_chance then
            local ret = potentialObject
            if key then
                return ret, i
            else
                return ret[1], i
            end
        end
    end
end

function StageAPI.Class(Type)
    local newClass = {}
    setmetatable(newClass, {
        __call = function(tbl, ...)
            local inst = {}
            setmetatable(inst, {
                __index = tbl
            })
            if inst.Init then
                inst:Init(...)
            end

            if inst.PostInit then
                inst:PostInit(...)
            end

            inst.Type = Type

            return inst
        end
    })
    return newClass
end

StageAPI.Callbacks = {}

local function Reverse_Iterator(t,i)
  i=i-1
  local v=t[i]
  if v==nil then return v end
  return i,v
end

function StageAPI.ReverseIterate(t)
    return Reverse_Iterator, t, #t+1
end

function StageAPI.AddCallback(id, priority, fn, ...)
    if not StageAPI.Callbacks[id] then
        StageAPI.Callbacks[id] = {}
    end

    local index = #StageAPI.Callbacks[id] + 1

    for i, callback in StageAPI.ReverseIterate(StageAPI.Callbacks[id]) do
        if callback.Priority > priority then
            index = i + 1
            break
        end
    end

    table.insert(StageAPI.Callbacks[id], index, {
        Priority = priority,
        Function = fn,
        Params = {...}
    })
end

function StageAPI.GetCallbacks(id)
    return StageAPI.Callbacks[id] or {}
end

function StageAPI.IsIn(tbl, v, fn)
    fn = fn or ipairs
    for k, v2 in fn(tbl) do
        if v2 == v then
            return k or true
        end
    end
end

function StageAPI.GetPlayingAnimation(sprite, animations)
    for _, anim in ipairs(animations) do
        if sprite:IsPlaying(anim) then
            return anim
        end
    end
end

function StageAPI.VectorToGrid(x, y, width)
    width = width or room:GetGridWidth()
    return width + 1 + (x + width * y)
end

function StageAPI.GridToVector(index, width)
    width = width or room:GetGridWidth()
    return (index % width) - 1, (math.floor(index / width)) - 1
end

function StageAPI.GetScreenCenterPosition()
    local centerOffset = (room:GetCenterPos()) - room:GetTopLeftPos()
    local pos = room:GetCenterPos()
    if centerOffset.X > 260 then
		pos.X = pos.X - 260
    end
    if centerOffset.Y > 140 then
        pos.Y = pos.Y - 140
    end
    return Isaac.WorldToRenderPosition(pos, false)
end

function StageAPI.GetScreenBottomRight()
	return StageAPI.GetScreenCenterPosition() * 2
end

local speedTests = {}
local standardDrop = 0
function StageAPI.SpeedTestStart(name)
    speedTests[name] = Isaac.GetTime()
end

function StageAPI.SpeedTestEnd(name, prefix)
    local testEnd = Isaac.GetTime()
    local diff = testEnd - speedTests[name] - standardDrop
    Isaac.DebugString((prefix or name or "") .. tostring(diff))
    return diff
end

StageAPI.SpeedTestStart("Speed Test Cost: ")
standardDrop = StageAPI.SpeedTestEnd("Speed Test Cost: ")


StageAPI.CorrectedGridTypes = {
    [1000]=GridEntityType.GRID_ROCK,
    [1001]=GridEntityType.GRID_ROCK_BOMB,
    [1002]=GridEntityType.GRID_ROCK_ALT,
    [1300]=GridEntityType.GRID_TNT,
    [1497]=GridEntityType.GRID_POOP,
    [1496]=GridEntityType.GRID_POOP,
    [1495]=GridEntityType.GRID_POOP,
    [1494]=GridEntityType.GRID_POOP,
    [1490]=GridEntityType.GRID_POOP,
    [1500]=GridEntityType.GRID_POOP,
    [1900]=GridEntityType.GRID_ROCKB,
    [1930]=GridEntityType.GRID_SPIKES,
    [1931]=GridEntityType.GRID_SPIKES_ONOFF,
    [1940]=GridEntityType.GRID_SPIDERWEB,
    [3000]=GridEntityType.GRID_PIT,
    [4000]=GridEntityType.GRID_LOCK,
    [4500]=GridEntityType.GRID_PRESSURE_PLATE,
    [9000]=GridEntityType.GRID_TRAPDOOR,
    [9100]=GridEntityType.GRID_STAIRS,
    [10000]=GridEntityType.GRID_GRAVITY
}

do -- Overlays
    StageAPI.DebugTiling = false
    function StageAPI.RenderSpriteTiled(sprite, position, size, centerCorrect)
        local screenBottomRight = StageAPI.GetScreenBottomRight()
        local screenFitX = screenBottomRight.X / size.X
        local screenFitY = screenBottomRight.Y / size.Y
        local timesRendered = 0
        for x = -1, math.ceil(screenFitX) do
            for y = -1, math.ceil(screenFitY) do
                local pos = position + Vector(size.X * x, size.Y * y)
                if centerCorrect then
                    pos = pos + Vector(
                        size.X * x,
                        size.Y * y
                    )
                end

                sprite:Render(pos, zeroVector, zeroVector)
                if StageAPI.DebugTiling then
                    timesRendered = timesRendered + 1
                    Isaac.RenderText("RenderPoint (" .. tostring(timesRendered) .. "): " .. tostring(x) .. ", " .. tostring(y), pos.X, pos.Y, 255, 0, 0, 1)
                end
            end
        end
    end

    StageAPI.OverlayDefaultSize = Vector(512, 512)
    StageAPI.Overlay = StageAPI.Class("Overlay")
    function StageAPI.Overlay:Init(file, velocity, offset, size)
        self.Sprite = Sprite()
        self.Sprite:Load(file, true)
        self.Sprite:Play("Idle", true)
        self.Position = zeroVector
        self.Velocity = velocity or zeroVector
        self.Offset = offset or zeroVector
        self.Size = size or StageAPI.OverlayDefaultSize
    end

    function StageAPI.Overlay:SetAlpha(alpha, noCancelFade)
        local sprite = self.Sprite
        sprite.Color = Color(sprite.Color.R, sprite.Color.G, sprite.Color.B, alpha, math.floor(sprite.Color.RO*255), math.floor(sprite.Color.GO*255), math.floor(sprite.Color.BO*255))
        if not noCancelFade then
            self.FadeTime = nil
            self.FadeTotal = nil
            self.FadeStep = nil
        end
    end

    function StageAPI.Overlay:Fade(total, time, step) -- use a step of -1 to fade out
        step = step or 1
        self.FadeTotal = total
        self.FadeTime = time
        self.FadeStep = step
    end

    function StageAPI.Overlay:Render(centerCorrect)
        centerCorrect = not centerCorrect
        if self.FadeTime and self.FadeTotal and self.FadeStep then
            self.FadeTime = self.FadeTime + self.FadeStep
            if self.FadeTime < 0 then
                self.FadeTime = 0
            end

            if self.FadeTime > self.FadeTotal then
                self.FadeTime = self.FadeTotal
            end

            self:SetAlpha(self.FadeTime / self.FadeTotal, true)
        end

        if self.Velocity then
            self.Position = self.Position + self.Velocity
            if self.Position.X >= self.Size.X then
                self.Position = Vector(0, self.Position.Y)
            end

            if self.Position.Y >= self.Size.Y then
                self.Position = Vector(self.Position.X, 0)
            end

            if self.Position.X < 0 then
                self.Position = Vector(self.Size.X, self.Position.Y)
            end

            if self.Position.Y < 0 then
                self.Position = Vector(self.Position.X, self.Size.Y)
            end
        end

        StageAPI.RenderSpriteTiled(self.Sprite, self.Position + (self.Offset or zeroVector), self.Size, centerCorrect)
    end
end

do -- RoomsList
    function StageAPI.SimplifyRoomLayout(layout)
        local outLayout = {
            GridEntities = {},
            Entities = {},
            EntitiesByIndex = {},
            Doors = {},
            Shape = layout.SHAPE,
            Weight = layout.WEIGHT,
            Difficulty = layout.DIFFICULTY,
            Name = layout.NAME,
            Width = layout.WIDTH + 2,
            Height = layout.HEIGHT + 2,
            Type = layout.TYPE,
            Variant = layout.VARIANT,
            SubType = layout.SUBTYPE
        }

        for _, object in ipairs(layout) do
            if not object.ISDOOR then
                if StageAPI.CorrectedGridTypes[object[1].TYPE] then
                    outLayout.GridEntities[#outLayout.GridEntities + 1] = {
                        Type = StageAPI.CorrectedGridTypes[object[1].TYPE],
                        Variant = object[1].VARIANT,
                        GridX = object.GRIDX,
                        GridY = object.GRIDY,
                        Index = StageAPI.VectorToGrid(object.GRIDX, object.GRIDY, outLayout.Width)
                    }
                elseif object[1].TYPE ~= 0 then
                    local entData = {
                        Type = object[1].TYPE,
                        Variant = object[1].VARIANT,
                        SubType = object[1].SUBTYPE,
                        GridX = object.GRIDX,
                        GridY = object.GRIDY,
                        Index = StageAPI.VectorToGrid(object.GRIDX, object.GRIDY, outLayout.Width)
                    }

                    if entData.Type == 1400 or entData.Type == 1410 then
                        entData.Type = EntityType.ENTITY_FIREPLACE
                    end

                    if not outLayout.EntitiesByIndex[entData.Index] then
                        outLayout.EntitiesByIndex[entData.Index] = {}
                    end

                    outLayout.EntitiesByIndex[entData.Index][#outLayout.EntitiesByIndex[entData.Index] + 1] = entData
                    outLayout.Entities[#outLayout.Entities + 1] = entData
                end
            else
                outLayout.Doors[#outLayout.Doors + 1] = {
                    Slot = object.SLOT,
                    Exists = object.EXISTS
                }
            end
        end

        return outLayout
    end

    StageAPI.RoomsList = StageAPI.Class("RoomsList")
    function StageAPI.RoomsList:Init(...)
        self.All = {}
        self.ByShape = {}
        self.Shapes = {}
        self:AddRooms(...)
    end

    function StageAPI.RoomsList:AddRooms(...)
        local roomfiles = {...}
        for _, rooms in ipairs(roomfiles) do
            local roomfile = "N/A"
            if rooms.Name and rooms.Rooms then
                roomfile = rooms.Name
                rooms = rooms.Rooms
            end

            for _, room in ipairs(rooms) do
                local simplified = StageAPI.SimplifyRoomLayout(room)
                simplified.RoomFilename = roomfile
                self.All[#self.All + 1] = simplified
                if not self.ByShape[simplified.Shape] then
                    self.Shapes[#self.Shapes + 1] = simplified.Shape
                    self.ByShape[simplified.Shape] = {}
                end

                self.ByShape[simplified.Shape][#self.ByShape[simplified.Shape] + 1] = simplified
            end
        end
    end

    function StageAPI.ClearRoomLayout(keepDecoration, doGrids, doEnts)
        if doEnts then
            for _, ent in ipairs(Isaac.GetRoomEntities()) do
                local etype = ent.Type
                if etype ~= EntityType.ENTITY_FAMILIAR and etype ~= EntityType.ENTITY_PLAYER and etype ~= EntityType.ENTITY_KNIFE then
                    ent:Remove()
                end
            end
        end

        if doGrids then
            for i = 0, room:GetGridSize() do
                local grid = room:GetGridEntity(i)
                if grid then
                    local gtype = grid.Desc.Type
                    if gtype ~= GridEntityType.GRID_WALL and gtype ~= GridEntityType.GRID_DOOR then
                        StageAPI.Room:RemoveGridEntity(i, 0, keepDecoration)
                    end
                end
            end
        end
    end

    StageAPI.RoomChooseRNG = RNG()
    function StageAPI.ChooseRoomLayout(roomList, seed)
        local callbacks = StageAPI.GetCallbacks("CHECK_VALID_ROOM")
        local validRooms = {}

        local shape = room:GetRoomShape()
        local possibleRooms = roomList[shape]
        if possibleRooms then
            for _, layout in ipairs(possibleRooms) do
                local isValid = true
                for _, door in ipairs(layout.Doors) do
                    if door.Slot then
                        if door.Exists then
                            if not room:IsDoorSlotAllowed(door.Slot) then
                                isValid = false
                                break
                            end
                        else
                            if room:GetDoor(door.Slot) then
                                isValid = false
                                break
                            end
                        end
                    end
                end

                for _, callback in ipairs(callbacks) do
                    if callback.Function(roomList) == false then
                        isValid = false
                        break
                    end
                end

                if isValid then
                    validRooms[#validRooms + 1] = {layout, layout.Weight}
                end
            end
        end

        if #validRooms > 0 then
            StageAPI.RoomChooseRNG:SetSeed(room:GetSpawnSeed(), 0)
            return StageAPI.WeightedRNG(validRooms, StageAPI.RoomChooseRNG)
        end
    end
    StageAPI.RoomLoadRNG = RNG()
    function StageAPI.LoadEntitiesFromDataList(entities, doGrids, doPersistentOnly)
        StageAPI.RoomLoadRNG:SetSeed(room:GetSpawnSeed(), 1)
        local ents_spawned = {}
        local callbacks = StageAPI.GetCallbacks("PRE_SPAWN_ENTITY_LIST")
        for index, entityList in pairs(entities) do
            if #entityList > 0 then
                local shouldSpawn = true
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function(entityList, index, doGrids)
                    if ret == false then
                        shouldSpawn = false
                        break
                    elseif ret and type(ret) == "table" then
                        entityList = ret
                        break
                    end
                end

                if shouldSpawn and #entityList > 0 then
                    local entityData = entityList[StageAPI.Random(1, #entityList, StageAPI.RoomLoadRNG)]

                    if not entityData.Position then
                        entityData.Position = room:GetGridPosition(index)
                    end

                    if doGrids or (entityData.Type > 9 and entityData.Type ~= EntityType.ENTITY_FIREPLACE) then
                        local ent = Isaac.Spawn(
                            entityData.Type or 20,
                            entityData.Variant or 0,
                            entityData.SubType or 0,
                            entityData.Position or StageAPI.ZeroVector,
                            StageAPI.ZeroVector,
                            nil
                        )

                        if ent:CanShutDoors() then
                            StageAPI.Room:SetClear(false)
                        end

                        ents_spawned[#ents_spawned + 1] = ent
                    end
                end
            end
        end

        return ents_spawned
    end

    function StageAPI.CallGridPostInit()
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                grid:PostInit()
            end
        end
    end

    function StageAPI.LoadGridsFromDataList(grids)
        local grids_spawned = {}
        local callbacks = StageAPI.GetCallbacks("PRE_SPAWN_GRID")
        for _, gridData in ipairs(grids) do
            local shouldSpawn = true
            for _, callback in ipairs(callbacks) do
                local ret = callback.Function(gridData)
                if ret == false then
                    shouldSpawn = false
                    break
                end
            end

            local index = gridData.Index
            if shouldSpawn and StageAPI.Room:IsPositionInRoom(StageAPI.Room:GetGridPosition(index), 0) then
                local grid = Isaac.GridSpawn(gridData.Type, gridData.Variant, StageAPI.Room:GetGridPosition(index), true)
                if grid then
                    if gridData.State ~= nil then
                        grid.State = gridData.State
                    end

                    if gridData.VarData ~= nil then
                        grid.VarData = gridData.VarData
                    end

                    grids_spawned[#grids_spawned + 1] = grid
                end
            end
        end

        StageAPI.CallGridPostInit()

        return grids_spawned
    end

    function StageAPI.LoadRoomLayout(layout, doGrids, doEnemies, doPersistentOnly)
        local grids_spawned = {}
        local ents_spawned = {}

        if doEnemies or doPersistentEntities then
            ents_spawned = StageAPI.LoadEntitiesFromDataList(layout.EntitiesByIndex, doGrids, doPersistentOnly)
        end

        StageAPI.Room:Update()

        if doGrids then
            grids_spawned = StageAPI.LoadGridsFromDataList(layout.GridEntities)
        end

        StageAPI.Room:Update()

        return ents_spawned, grids_spawned
    end

    function StageAPI.ConvertRoomLayout(roomsList)
        StageAPI.ClearRoomLayout(false, isFirst, isFirst)
        room:Update()
        local layout = StageAPI.ChooseRoomLayout(roomList)
        StageAPI.LoadRoomLayout(layout, true, true)
    end

    function StageAPI.GenerateRoom(roomList, isClear, isFirst, layout)
        StageAPI.ClearRoomLayout(false, isFirst, isFirst)
        room:Update()
        if not layout then
            layout = StageAPI.ChooseRoomLayout(roomList)
        end

        StageAPI.LoadRoomLayout(layout, isFirst, not isClear)
        return layout
    end
end

do -- GridGfx
    StageAPI.GridGfx = StageAPI.Class("GridGfx")
    function StageAPI.GridGfx:SetRocks(filename)
        self.Rocks = filename
    end

    function StageAPI.GridGfx:SetGrid(filename, t, v)
        if not self.Grids then
            self.Grids = {}
            self.GridsByVariant = {}
        end

        if v then
            self.GridsByVariant[t] = {
                [v] = filename
            }
        else
            self.Grids[t] = filename
        end
    end

    function StageAPI.GridGfx:SetPits(filename, alt)
        self.Pits = filename
        self.AltPits = alt
    end

    function StageAPI.GridGfx:SetBridges(filename)
        self.Bridges = filename
    end

    function StageAPI.GridGfx:SetDecorations(filename)
        self.Decorations = filename
    end

    StageAPI.PoopVariant = {
        Normal = 0,
        Red = 1,
        Eternal = 2,
        Golden = 3,
        Black = 4
    }

    -- No SetPoop, do GridGfx:SetGrid(filename, GridEntityType.GRID_POOP, StageAPI.PoopVariant.Normal)

    StageAPI.DefaultDoorSpawn = {
        RequireCurrent = {RoomType.ROOM_DEFAULT, RoomType.ROOM_MINIBOSS, RoomType.ROOM_SACRIFICE, RoomType.ROOM_SHOP, RoomType.ROOM_LIBRARY},
        RequireTarget = {RoomType.ROOM_DEFAULT, RoomType.ROOM_MINIBOSS, RoomType.ROOM_SACRIFICE, RoomType.ROOM_SHOP, RoomType.ROOM_LIBRARY}
    }

    StageAPI.SecretDoorSpawn = {
        RequireTarget = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET},
        NotCurrent = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET}
    }
    --[[
    DoorInfo
    {
        RequireCurrent = {},
        RequireTarget = {},
        RequireEither = {},
        NotCurrent = {},
        NotTarget = {},
        NotEither = {}
    }
    ]]
    function StageAPI.GridGfx:AddDoors(filename, doorInfo)
        self.Doors = self.Doors or {}
        doorInfo.File = filename
        self.Doors[#self.Doors + 1] = doorInfo
    end


    StageAPI.RockAnimationMap = {
        "normal",
        "black",
        "tinted",
        "alt",
        "bombrock",
        "big",
        "superspecial",
        "ss_broken"
    }

    StageAPI.RockSprite = Sprite()
    StageAPI.RockSprite:Load("gfx/grid/grid_rock.anm2", true)
    function StageAPI.ChangeRock(rock, filename)
        local grid = rock.Grid:ToRock()

        for i = 0, 4 do
            StageAPI.RockSprite:ReplaceSpritesheet(i, filename)
        end
        StageAPI.RockSprite:LoadGraphics()

        grid.Sprite = StageAPI.RockSprite
        grid.Sprite:Play(grid.Anim, true)
        grid:UpdateAnimFrame()
    end

    StageAPI.BridgeEntities = {}
    mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
        StageAPI.BridgeEntities = {}
    end)

    StageAPI.BridgeOffset = Vector(3, 3)

    function StageAPI.CheckBridge(grid, index, bridgefilename)
        if grid.State == 1 and bridgefilename and not StageAPI.BridgeEntities[index] then
            local bridge = Isaac.Spawn(StageAPI.E.Bridge.T, StageAPI.E.Bridge.V, 0, room:GetGridPosition(index), zeroVector, nil)
            local sprite = bridge:GetSprite()
            sprite:Load("stageapi/bridge.anm2", false)
            sprite:ReplaceSpritesheet(0, bridgefilename)
            sprite:LoadGraphics()

            bridge:AddEntityFlags(EntityFlag.FLAG_DONT_OVERWRITE)
            bridge.SpriteOffset = StageAPI.BridgeOffset
            bridge.RenderZOffset = -10000
            StageAPI.BridgeEntities[index] = bridge
        end
    end

    StageAPI.PitSprite = Sprite()
    StageAPI.PitSprite:Load("gfx/grid/grid_pit.anm2", true)
    function StageAPI.ChangePit(pit, filename, bridgefilename, alt)
        local grid = pit.Grid

        if alt and room:HasWaterPits() then
            StageAPI.PitSprite:ReplaceSpritesheet(0, alt)
        else
            StageAPI.PitSprite:ReplaceSpritesheet(0, filename)
        end

        StageAPI.PitSprite:LoadGraphics()

        grid.Sprite = StageAPI.PitSprite

        StageAPI.CheckBridge(grid, pit.Index, bridgefilename)
    end

    StageAPI.DecorationSprite = Sprite()
    StageAPI.DecorationSprite:Load("gfx/grid/props_03_caves.anm2", true)
    StageAPI.DecorationRNG = RNG()
    function StageAPI.ChangeDecoration(decoration, filename)
        local grid = decoration.Grid

        StageAPI.DecorationSprite:ReplaceSpritesheet(0, filename)
        StageAPI.DecorationSprite:LoadGraphics()
        StageAPI.DecorationRNG:SetSeed(room:GetDecorationSeed(), decoration.Index)

        local prop = StageAPI.Random(1, 42, StageAPI.DecorationRNG)
        if prop < 10 then
            prop = "0" .. tostring(prop)
        end

        StageAPI.DecorationSprite:Play("Prop" .. tostring(prop), true)
        grid.Sprite = StageAPI.DecorationSprite
    end

    StageAPI.DoorAnimationMap = {
        "Opened",
        "Closed",
        "Open",
        "Close",
        "Break",
        "KeyOpen",
        "KeyClose",
        "BrokenOpen",
        "KeyClosed",
        "Hidden",
        "GoldenKeyOpen"
    }

    StageAPI.DoorSprite = Sprite()
    function StageAPI.ChangeDoor(door, doors)
        local grid = door.Grid:ToDoor()
        local current = grid.CurrentRoomType
        local target = grid.TargetRoomType
        for _, doorOption in ipairs(doors) do
            local valid = true
            if doorOption.RequireCurrent then
                local has = false
                for _, roomType in ipairs(doorOption.RequireCurrent) do
                    if current == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.RequireTarget then
                local has = false
                for _, roomType in ipairs(doorOption.RequireTarget) do
                    if target == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.RequireEither then
                local has = false
                for _, roomType in ipairs(doorOption.RequireEither) do
                    if current == roomType or target == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.NotCurrent then
                local has = false
                for _, roomType in ipairs(doorOption.NotCurrent) do
                    if current == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if doorOption.NotTarget then
                local has = false
                for _, roomType in ipairs(doorOption.NotTarget) do
                    if target == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if doorOption.NotEither then
                local has = false
                for _, roomType in ipairs(doorOption.NotEither) do
                    if current == roomType or target == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if valid then
                local sprite = grid.Sprite
                for i = 0, 5 do
                    sprite:ReplaceSpritesheet(i, doorOption.File)
                end

                sprite:LoadGraphics()

                grid.Sprite = sprite

                break
            end
        end
    end

    StageAPI.GridGfxAltRNG = RNG()
    function StageAPI.ChangeGrid(sent, filename)
        local grid = sent.Grid
        local sprite = grid.Sprite

        if type(filename) == "table" then
            StageAPI.GridGfxAltRNG:SetSeed(room:GetDecorationSeed(), sent.Index)
            filename = filename[StageAPI.Random(1, #filename, StageAPI.GridGfxAltRNG)]
        end

        sprite:ReplaceSpritesheet(0, filename)
        sprite:LoadGraphics()
        grid.Sprite = sprite
    end

    function StageAPI.ChangeSingleGrid(grid, grids, i)
        local desc = grid.Desc
        local gtype = desc.Type
        local send = {Grid = grid, Index = i, Type = gtype, Desc = desc}
        if gtype == GridEntityType.GRID_DOOR and grids.Doors then
            StageAPI.ChangeDoor(send, grids.Doors)
        elseif grid:ToRock() and grids.Rocks then
            StageAPI.ChangeRock(send, grids.Rocks)
        elseif gtype == GridEntityType.GRID_PIT and grids.Pits then
            StageAPI.ChangePit(send, grids.Pits, grids.Bridges, grids.AltPits)
        elseif gtype == GridEntityType.GRID_DECORATION and grids.Decorations then
            StageAPI.ChangeDecoration(send, grids.Decorations)
        elseif grids.Grids or grids.GridsByVariant then
            local variant = send.Desc.Variant
            if grids.GridsByVariant and grids.GridsByVariant[send.Type] and grids.GridsByVariant[send.Type][variant] then
                StageAPI.ChangeGrid(send, grids.GridsByVariant[send.Type][variant])
            elseif grids.Grids and grids.Grids[send.Type] then
                StageAPI.ChangeGrid(send, grids.Grids[send.Type])
            end
        end
    end

    function StageAPI.ChangeGrids(grids)
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                StageAPI.ChangeSingleGrid(grid, grids, i)
            end
        end

        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                grid:PostInit()
            end
        end
    end
end

do -- Backdrop & RoomGfx
    StageAPI.BackdropRNG = RNG()
    local backdropDefaultOffset = Vector(260,0)
    local backdropIvOffset = Vector(113,0)
    function StageAPI.ChangeBackdrop(backdrop)
        StageAPI.BackdropRNG:SetSeed(room:GetDecorationSeed(), 1)
        local roomShape = room:GetRoomShape()
        local backdropEntity = Isaac.Spawn(StageAPI.E.Backdrop.T, StageAPI.E.Backdrop.V, 0, zeroVector, zeroVector, nil)
        local sprite = backdropEntity:GetSprite()
        sprite:Load("stageapi/Backdrop.anm2", false)

        for num = 0, 15 do
            local wall_to_use = backdrop.Walls[StageAPI.Random(1, #backdrop.Walls, backdropRNG)]
            sprite:ReplaceSpritesheet(num, wall_to_use)
        end

        local nfloor_to_use = backdrop.NFloors[StageAPI.Random(1, #backdrop.NFloors, backdropRNG)]
        local lfloor_to_use = backdrop.LFloors[StageAPI.Random(1, #backdrop.LFloors, backdropRNG)]
        local corner_to_use = backdrop.Corners[StageAPI.Random(1, #backdrop.Corners, backdropRNG)]
        for num = 16, 17 do
            sprite:ReplaceSpritesheet(num, nfloor_to_use)
        end

        for num = 18, 22 do
            sprite:ReplaceSpritesheet(num, lfloor_to_use)
        end

        sprite:ReplaceSpritesheet(23, corner_to_use)
        sprite:LoadGraphics()

        local topLeft = room:GetTopLeftPos()
        local renderPos = topLeft + backdropDefaultOffset

        if roomShape == RoomShape.ROOMSHAPE_1x1 then sprite:Play("1x1_room", true)
        elseif roomShape ==  RoomShape.ROOMSHAPE_IH then sprite:Play("IH_room", true)
        elseif roomShape ==  RoomShape.ROOMSHAPE_IV then
            sprite:Play("IV_room", true)
            renderPos = topLeft + backdropIvOffset
        elseif roomShape ==  RoomShape.ROOMSHAPE_1x2 then sprite:Play("1x2_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_IIV then
            sprite:Play("IIV_room", true)
            renderPos = topLeft + backdropIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_2x1 then sprite:Play("2x1_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_IIH then sprite:Play("IIH_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_2x2 then sprite:Play("2x2_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LTL then sprite:Play("LTL_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LTR then sprite:Play("LTR_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LBL then sprite:Play("LBL_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LBR then sprite:Play("LBR_room", true) end

        backdropEntity.Position = renderPos
        backdropEntity:AddEntityFlags(EntityFlag.FLAG_RENDER_WALL | EntityFlag.FLAG_RENDER_FLOOR)
    end

    local shadingDefaultOffset = Vector(-80,-80)
    local shadingIhOffset = Vector(-80,-160)
    local shadingIvOffset = Vector(-240,-80)
    function StageAPI.ChangeShading(name, prefix)
        prefix = prefix or "stageapi/shading/shading"
        local shading = Isaac.FindByType(StageAPI.E.Shading.T, StageAPI.E.Shading.V, -1, false, false)
        for _, e in ipairs(shading) do
            e:Remove()
        end

        local shadingEntity = Isaac.Spawn(StageAPI.E.Shading.T, StageAPI.E.Shading.V, 0, zeroVector, zeroVector, nil)
        local roomShape = room:GetRoomShape()

        local topLeft = room:GetTopLeftPos()
        local renderPos = topLeft + shadingDefaultOffset
        local sheet

        if roomShape == RoomShape.ROOMSHAPE_1x1 then sheet = ""
        elseif roomShape == RoomShape.ROOMSHAPE_1x2 then sheet = "_1x2"
        elseif roomShape == RoomShape.ROOMSHAPE_2x1 then sheet = "_2x1"
        elseif roomShape == RoomShape.ROOMSHAPE_2x2 then sheet = "_2x2"
        elseif roomShape == RoomShape.ROOMSHAPE_IH then
            sheet = "_ih"
            renderPos = topLeft + shadingIhOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IIH then
            sheet = "_iih"
            renderPos = topLeft + shadingIhOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IV then
            sheet = "_iv"
            renderPos = topLeft + shadingIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IIV then
            sheet = "_iiv"
            renderPos = topLeft + shadingIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_LBL then sheet = "_lbl"
        elseif roomShape == RoomShape.ROOMSHAPE_LBR then sheet = "_lbr"
        elseif roomShape == RoomShape.ROOMSHAPE_LTL then sheet = "_ltl"
        elseif roomShape == RoomShape.ROOMSHAPE_LTR then sheet = "_ltr"
        end

        sheet = prefix .. sheet .. name .. ".png"

        local sprite = shadingEntity:GetSprite()
        sprite:Load("stageapi/Shading.anm2", false)
        sprite:ReplaceSpritesheet(0, sheet)
        sprite:LoadGraphics()

        shadingEntity.Position = renderPos
        shadingEntity:AddEntityFlags(EntityFlag.FLAG_DONT_OVERWRITE)
    end

    function StageAPI.ChangeRoomGfx(roomgfx)
        StageAPI.BackdropRNG:SetSeed(room:GetDecorationSeed(), 0)
        if #roomgfx.Backdrops > 0 then
            local backdrop = StageAPI.Random(1, #roomgfx.Backdrops, StageAPI.BackdropRNG)
            StageAPI.ChangeBackdrop(roomgfx.Backdrops[backdrop])
        else
            StageAPI.ChangeBackdrop(roomgfx.Backdrops)
        end

        StageAPI.ChangeGrids(roomgfx.Grids)
        StageAPI.ChangeShading(roomgfx.Shading.Name, roomgfx.Shading.Prefix)
    end

    StageAPI.RoomGfx = StageAPI.Class("RoomGfx")
    function StageAPI.RoomGfx:Init(backdrops, grids, shading, shadingPrefix)
        self.Backdrops = backdrops
        self.Grids = grids
        self.Shading = {
            Name = shading,
            Prefix = shadingPrefix
        }
    end
end

do -- Custom Stage
    StageAPI.CustomStages = {}

    StageAPI.CustomStage = StageAPI.Class("CustomStage")
    function StageAPI.CustomStage:Init(name)
        self.Name = name
        if name then
            StageAPI.CustomStages[name] = self
        end
    end

    function StageAPI.CustomStage:SetRoomGfx(gfx, rtype)
        if not self.RoomGfx then
            self.RoomGfx = {}
        end

        if type(rtype) == "table" then
            for _, roomtype in ipairs(rtype) do
                self.RoomGfx[roomtype] = gfx
            end
        else
            self.RoomGfx[rtype] = gfx
        end
    end

    function StageAPI.CustomStage:SetRooms(rooms)
        self.Rooms = rooms
    end

    function StageAPI.CustomStage:SetMusic(music, rtype)
        if not self.Music then
            self.Music = {}
        end

        if type(rtype) == "table" then
            for _, roomtype in ipairs(rtype) do
                self.Music[roomtype] = music
            end
        else
            self.Music[rtype] = music
        end
    end

    function StageAPI.CustomStage:SetBossMusic(music, clearedMusic)
        self.BossMusic = {
            Fight = music,
            Cleared = clearedMusic
        }
    end

    function StageAPI.CustomStage:SetSpots(bossSpot, playerSpot)
        self.BossSpot = bossSpot
        self.PlayerSpot = playerSpot
    end

    function StageAPI.CustomStage:GetPlayingMusic()
        local roomType = room:GetType()
        local id = StageAPI.Music:GetCurrentMusicID()
        if roomType == RoomType.ROOM_BOSS then
            local music = self.BossMusic
            local musicID
            if room:IsClear() then
                musicID = music.Cleared
            else
                musicID = music.Fight
            end

            if type(musicID) == "table" then
                StageAPI.MusicRNG:SetSeed(room:GetDecorationSeed(), 0)
                musicID = musicID[StageAPI.Random(1, #musicID, StageAPI.MusicRNG)]
            end

            if musicID and not StageAPI.IsIn(StageAPI.NonOverrideMusic, id) then
                return musicID, not room:IsClear()
            end
        else
            local music = self.Music
            local musicID = music[roomType]
            if musicID and not StageAPI.IsIn(StageAPI.NonOverrideMusic, id) then
                return musicID, not room:IsClear()
            end
        end
    end

    function StageAPI.CustomStage:IsStage()
        return StageAPI.CurrentStage and StageAPI.CurrentStage.Name == self.Name
    end
end

do -- Definitions
    function StageAPI.BackdropHelper(backdrop, prefix, suffix)
        if #backdrop < 1 then
            backdrop = {backdrop}
        end

        for i, backdropVariant in ipairs(backdrop) do
            for k, backdropFiles in pairs(backdropVariant) do
                for i2, file in ipairs(backdropFiles) do
                    backdrop[i][k][i2] = prefix .. file .. suffix
                end
            end
        end

        return backdrop
    end

    StageAPI.CatacombsGridGfx = StageAPI.GridGfx()
    StageAPI.CatacombsGridGfx:SetRocks("gfx/grid/rocks_catacombs.png")
    StageAPI.CatacombsGridGfx:SetPits("gfx/grid/grid_pit_catacombs.png", "gfx/grid/grid_pit_water_catacombs.png")
    StageAPI.CatacombsGridGfx:SetBridges("gfx/grid/grid_bridge_catacombs.png")
    StageAPI.CatacombsGridGfx:SetDecorations("gfx/grid/props_03_caves.png")

    StageAPI.CatacombsBackdrop = {
        {
            Walls = {"Catacombs1_1", "Catacombs1_2"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs1_corner"}
        },
        {
            Walls = {"Catacombs2_1", "Catacombs2_2"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs2_corner"}
        }
    }

    StageAPI.CatacombsBackdrop = StageAPI.BackdropHelper(StageAPI.CatacombsBackdrop, "stageapi/backdrops/catacombs/", ".png")
    StageAPI.CatacombsRoomGfx = StageAPI.RoomGfx(StageAPI.CatacombsBackdrop, StageAPI.CatacombsGridGfx, "_default")
    StageAPI.CatacombsMusicID = Isaac.GetMusicIdByName("Catacombs")
    StageAPI.CatacombsRooms = StageAPI.RoomsList(require("catacombs"))
    StageAPI.Catacombs = StageAPI.CustomStage("Catacombs")
    StageAPI.Catacombs:SetMusic(StageAPI.CatacombsMusicID, RoomType.ROOM_DEFAULT)
    StageAPI.Catacombs:SetBossMusic({Music.MUSIC_BOSS, Music.MUSIC_BOSS2}, Music.MUSIC_BOSS_OVER)
    StageAPI.Catacombs:SetRoomGfx(StageAPI.CatacombsRoomGfx, {RoomType.ROOM_DEFAULT, RoomType.ROOM_TREASURE, RoomType.ROOM_MINIBOSS, RoomType.ROOM_BOSS})
    StageAPI.Catacombs:SetRooms(StageAPI.CatacombsRooms)

    StageAPI.StageOverride = {
        {
            OverrideStages = {LevelStage.STAGE2_1, LevelStage.STAGE2_2},
            OverrideStageTypes = {StageType.STAGETYPE_WOTL},
            ReplaceWith = StageAPI.Catacombs
        }
    }

    function StageAPI.InOverriddenStage()
        for _, override in ipairs(StageAPI.StageOverride) do
            local overridden = true

            local isStage = false
            for _, stage in ipairs(override.OverrideStages) do
                if level:GetStage() == stage then
                    isStage = true
                end
            end

            if isStage then
                local isStageType = false
                for _, stageType in ipairs(override.OverrideStageTypes) do
                    if level:GetStageType() == stageType then
                        isStageType = true
                    end
                end

                if isStageType then
                    return true, override
                end
            end
        end
    end

    StageAPI.NextStage = nil
    StageAPI.CurrentStage = nil
    StageAPI.LevelRooms = {}

    function StageAPI.InNewStage()
        return StageAPI.CurrentStage and StageAPI.CurrentStage.Name ~= "Catacombs"
    end

    function StageAPI.GetCurrentListIndex()
        return level:GetCurrentRoomDesc().ListIndex
    end
end

do -- Bosses
    StageAPI.BossSpots = {
        [LevelStage.STAGE1_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "01_basement",
            [StageType.STAGETYPE_WOTL] = "02_cellar",
            [StageType.STAGETYPE_AFTERBIRTH] = "13_burning_basement",
            [StageType.STAGETYPE_GREEDMODE] = "01_basement"
        },
        [LevelStage.STAGE1_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "01_basement",
            [StageType.STAGETYPE_WOTL] = "02_cellar",
            [StageType.STAGETYPE_AFTERBIRTH] = "13_burning_basement",
            [StageType.STAGETYPE_GREEDMODE] = "01_basement"
        },
        [LevelStage.STAGE2_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "03_caves",
            [StageType.STAGETYPE_WOTL] = "04_catacombs",
            [StageType.STAGETYPE_AFTERBIRTH] = "14_drowned_caves",
            [StageType.STAGETYPE_GREEDMODE] = "03_caves"
        },
        [LevelStage.STAGE2_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "03_caves",
            [StageType.STAGETYPE_WOTL] = "04_catacombs",
            [StageType.STAGETYPE_AFTERBIRTH] = "14_drowned_caves",
            [StageType.STAGETYPE_GREEDMODE] = "03_caves"
        },
        [LevelStage.STAGE3_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "05_depths",
            [StageType.STAGETYPE_WOTL] = "06_necropolis",
            [StageType.STAGETYPE_AFTERBIRTH] = "15_dank_depths",
            [StageType.STAGETYPE_GREEDMODE] = "05_depths"
        },
        [LevelStage.STAGE3_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "05_depths",
            [StageType.STAGETYPE_WOTL] = "06_necropolis",
            [StageType.STAGETYPE_AFTERBIRTH] = "15_dank_depths",
            [StageType.STAGETYPE_GREEDMODE] = "05_depths"
        },
        [LevelStage.STAGE4_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "07_womb",
            [StageType.STAGETYPE_WOTL] = "07_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "16_scarred_womb",
            [StageType.STAGETYPE_GREEDMODE] = "07_womb"
        },
        [LevelStage.STAGE4_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "07_womb",
            [StageType.STAGETYPE_WOTL] = "07_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "16_scarred_womb",
            [StageType.STAGETYPE_GREEDMODE] = "07_womb"
        },
        [LevelStage.STAGE4_3] = {
            [StageType.STAGETYPE_ORIGINAL] = "17_blue_womb",
            [StageType.STAGETYPE_WOTL] = "17_blue_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "17_blue_womb",
            [StageType.STAGETYPE_GREEDMODE] = "17_blue_womb"
        },
        [LevelStage.STAGE5] = {
            [StageType.STAGETYPE_ORIGINAL] = "09_sheol",
            [StageType.STAGETYPE_WOTL] = "10_cathedral",
            [StageType.STAGETYPE_AFTERBIRTH] = "09_sheol",
            [StageType.STAGETYPE_GREEDMODE] = "09_sheol"
        },
        [LevelStage.STAGE6] = {
            [StageType.STAGETYPE_ORIGINAL] = "11_darkroom",
            [StageType.STAGETYPE_WOTL] = "12_chest",
            [StageType.STAGETYPE_AFTERBIRTH] = "11_darkroom",
            [StageType.STAGETYPE_GREEDMODE] = "18_shop"
        },
        [LevelStage.STAGE7] = {
            [StageType.STAGETYPE_ORIGINAL] = "19_void",
            [StageType.STAGETYPE_WOTL] = "19_void",
            [StageType.STAGETYPE_AFTERBIRTH] = "19_void",
            [StageType.STAGETYPE_GREEDMODE] = "18_shop"
        }
    }

    StageAPI.PlayerBossInfo = {
        isaac = "01",
        magdalene = "02",
        cain = "03",
        judas = "04",
        eve = "05",
        ["???"] = "06",
        samson = "07",
        azazel = "08",
        eden = "09",
        thelost = "12",
        lilith = "13",
        keeper = "14",
        apollyon = "15"
    }

    for k, v in pairs(StageAPI.PlayerBossInfo) do
        local use = k
        if k == "???" then
            use = "bluebaby"
        end

        StageAPI.PlayerBossInfo[k] = {
            Portrait = "gfx/ui/boss/playerportrait_" .. v .. "_" .. use .. ".png",
            Name = "gfx/ui/boss/playername_" .. v .. "_" .. use .. ".png"
        }
    end

    function StageAPI.AddPlayerBossInfo(name, portrait, namefile)
        StageAPI.PlayerBossInfo[string.gsub(string.lower(name), "%s+", "")] = {
            Portrait = portrait,
            Name = namefile
        }
    end

    StageAPI.AddPlayerBossInfo("Black Judas", "gfx/ui/boss/playerportrait_blackjudas.png", "gfx/ui/boss/playername_04_judas.png")
    StageAPI.AddPlayerBossInfo("Lazarus", "gfx/ui/boss/playerportrait_09_lazarus.png", "gfx/ui/boss/playername_10_lazarus.png")
    StageAPI.AddPlayerBossInfo("Lazarus 2", "gfx/ui/boss/playerportrait_10_lazarus2.png", "gfx/ui/boss/playername_10_lazarus.png")

    function StageAPI.GetStageSpot()
        if StageAPI.InNewStage() then
            return StageAPI.CurrentStage.BossSpot or "gfx/ui/boss/bossspot.png", StageAPI.CurrentStage.PlayerSpot or "gfx/ui/boss/playerspot.png"
        else
            local stage, stype = level:GetStage(), level:GetStageType()
            local spot = StageAPI.BossSpots[stage][stype]
            return "gfx/ui/boss/bossspot_" .. spot .. ".png", "gfx/ui/boss/playerspot_" .. spot .. ".png"
        end
    end

    function StageAPI.TryGetPlayerBossInfo(player)
        local playerName = string.gsub(string.lower(player:GetName()), "%s+", "")
        if StageAPI.PlayerBossInfo[playerName] then
            return StageAPI.PlayerBossInfo[playerName].Portrait, StageAPI.PlayerBossInfo[playerName].Name
        else -- worth a shot, most common naming convention
            return "gfx/ui/boss/playerportrait_" .. playerName .. ".png", "gfx/ui/boss/playername_" .. playerName .. ".png"
        end
    end

    StageAPI.BossSprite = Sprite()
    StageAPI.BossSprite:Load("gfx/ui/boss/versusscreen.anm2", false)
    function StageAPI.PlayBossAnimationManual(portrait, name, spot, playerPortrait, playerName, playerSpot, portraitTwo)
        spot = spot or "gfx/ui/boss/bossspot.png"
        name = name or "gfx/ui/boss/bossname_20.0_monstro.png"
        portrait = portrait or "gfx/ui/boss/portrait_20.0_monstro.png"
        playerSpot = playerSpot or "gfx/ui/boss/bossspot.png"
        playerName = playerName or "gfx/ui/boss/bossname_20.0_monstro.png"
        playerPortrait = playerPortrait or "gfx/ui/boss/portrait_20.0_monstro.png"

        StageAPI.BossSprite:ReplaceSpritesheet(2, spot)
        StageAPI.BossSprite:ReplaceSpritesheet(3, playerSpot)
        StageAPI.BossSprite:ReplaceSpritesheet(4, portrait)
        StageAPI.BossSprite:ReplaceSpritesheet(5, playerPortrait)
        StageAPI.BossSprite:ReplaceSpritesheet(6, playerName)
        StageAPI.BossSprite:ReplaceSpritesheet(7, name)

        if portraitTwo then
            StageAPI.BossSprite:ReplaceSpritesheet(9, portraitTwo)
            StageAPI.BossSprite:Play("DoubleTrouble", true)
        else
            StageAPI.BossSprite:Play("Scene", true)
        end

        StageAPI.BossSprite:LoadGraphics()
    end

    StageAPI.IsOddRenderFrame = nil
    mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
        StageAPI.IsOddRenderFrame = not StageAPI.IsOddRenderFrame
        if StageAPI.BossSprite:IsPlaying("Scene") or StageAPI.BossSprite:IsPlaying("DoubleTrouble") then
            if StageAPI.IsOddRenderFrame then
                StageAPI.BossSprite:Update()
            end

            if Input.IsActionTriggered(ButtonAction.ACTION_MENUCONFIRM, StageAPI.Players[1].ControllerIndex) then
                StageAPI.BossSprite:Stop()
            else
                StageAPI.BossSprite:Render(StageAPI.GetScreenCenterPosition(), zeroVector, zeroVector)
            end
        end
    end)

    StageAPI.DummyBoss = {}
    function StageAPI.PlayBossAnimation(boss)
        local bSpot, pSpot = StageAPI.GetStageSpot()
        local playerPortrait, playerName = StageAPI.TryGetPlayerBossInfo(StageAPI.Players[1])
        StageAPI.PlayBossAnimationManual(boss.Portrait, boss.Name, boss.Spot or bSpot, playerPortrait, playerName, pSpot, boss.PortraitTwo)
    end
end

do -- Callbacks
    StageAPI.NonOverrideMusic = {
        Music.MUSIC_GAME_OVER,
        Music.MUSIC_JINGLE_SECRETROOM_FIND,
        Music.MUSIC_JINGLE_NIGHTMARE,
        Music.MUSIC_JINGLE_GAME_START,
        Music.MUSIC_JINGLE_BOSS,
        Music.MUSIC_JINGLE_BOSS_OVER,
        Music.MUSIC_JINGLE_BOSS_OVER2,
        Music.MUSIC_JINGLE_DEVILROOM_FIND,
        Music.MUSIC_JINGLE_HOLYROOM_FIND
    }

    function StageAPI.StopOverridingMusic(music)
        StageAPI.NonOverrideMusic[#StageAPI.NonOverrideMusic + 1] = music
    end

    mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
        local currentListIndex = StageAPI.GetCurrentListIndex()
        if StageAPI.LevelRooms[currentListIndex] then
            StageAPI.LevelRooms[currentListIndex].IsClear = room:IsClear()
        end
    end)

    StageAPI.RoomNamesEnabled = false
    StageAPI.OldBackdropType = nil
    StageAPI.PreviousGridCount = nil

    mod:AddCallback(ModCallbacks.MC_PRE_USE_ITEM, function(_, item)
        if item == CollectibleType.COLLECTIBLE_D12 then
            StageAPI.PreviousGridCount = nil
        end
    end)

    StageAPI.Music = MusicManager()
    StageAPI.MusicRNG = RNG()
    mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
        local currentListIndex = StageAPI.GetCurrentListIndex()
        local stage = level:GetStage()
        local stype = level:GetStageType()
        if StageAPI.InOverriddenStage() then
            if StageAPI.CurrentStage then
                local roomType = room:GetType()
                local rtype
                local currentRoom = StageAPI.LevelRooms[currentListIndex]
                if currentRoom and currentRoom.TypeOverride then
                    rtype = currentRoom.TypeOverride
                else
                    rtype = roomType
                end

                local grids
                local gridsOverride
                local callbacks = StageAPI.GetCallbacks("PRE_UPDATE_GRID_GFX")
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function()
                    if ret then
                        gridsOverride = ret
                    end
                end

                if not gridsOverride and StageAPI.CurrentStage.RoomGfx and StageAPI.CurrentStage.RoomGfx[rtype] and StageAPI.CurrentStage.RoomGfx[rtype].Grids then
                    grids = StageAPI.CurrentStage.RoomGfx[rtype].Grids
                elseif gridsOverride then
                    grids = gridsOverride
                end

                if grids then
                    local gridCount = 0
                    for i = 0, room:GetGridSize() do
                        local grid = room:GetGridEntity(i)
                        if grid then
                            local bridgefilename = grids.Bridges
                            if bridgefilename then
                                if grid.Desc.Type == GridEntityType.GRID_PIT then
                                    StageAPI.CheckBridge(grid, i, bridgefilename)
                                end
                            end

                            gridCount = gridCount + 1
                        end
                    end

                    if gridCount ~= StageAPI.PreviousGridCount then
                        StageAPI.ChangeGrids(grids)
                        StageAPI.PreviousGridCount = gridCount
                    end
                end

                local id = StageAPI.Music:GetCurrentMusicID()
                local musicID, shouldLayer = StageAPI.CurrentStage:GetPlayingMusic()
                if musicID then
                    StageAPI.Music:Queue(musicID)
                    StageAPI.Music:UpdateVolume()
                    if id ~= musicID then
                        StageAPI.Music:Play(musicID, 0.1)
                        StageAPI.Music:UpdateVolume()
                    end

                    if shouldLayer and not StageAPI.Music:IsLayerEnabled() then
                        StageAPI.Music:EnableLayer()
                    elseif not shouldLayer and StageAPI.Music:IsLayerEnabled() then
                        StageAPI.Music:DisableLayer()
                    end
                end
            end
        end

        local btype = room:GetBackdropType()
        if StageAPI.OldBackdropType ~= btype then
            if btype == 5 and not StageAPI.InOverriddenStage() then
                StageAPI.ChangeRoomGfx(StageAPI.CatacombsRoomGfx)
            end

            StageAPI.OldBackdropType = btype
        end

        for _, player in ipairs(players) do
            if Input.IsButtonTriggered(Keyboard.KEY_F5, player.ControllerIndex) then
                StageAPI.RoomNamesEnabled = not StageAPI.RoomNamesEnabled
            end
        end

        if StageAPI.RoomNamesEnabled then
            local currentRoom = StageAPI.LevelRooms[currentListIndex]
            if currentRoom and currentRoom.RoomFilename and currentRoom.Name and currentRoom.Variant then
                Isaac.RenderText("Room File: " .. currentRoom.RoomFilename .. ", Name: " .. currentRoom.Name .. ", ID: " .. tostring(currentRoom.Variant), 60, 35, 255, 255, 255, 1)
            end
        end
    end)

    mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
        local stage = level:GetStage()
        local stype = level:GetStageType()
        local isNewStage, override = StageAPI.InOverriddenStage()
        if isNewStage then
            local currentListIndex = level:GetCurrentRoomDesc().ListIndex
            local currentRoom = StageAPI.LevelRooms[currentListIndex]
            if level:GetCurrentRoomIndex() == level:GetStartingRoomIndex() then
                if room:IsFirstVisit() then
                    currentRoom = nil
                    StageAPI.LevelRooms = {}
                    if not StageAPI.NextStage then
                        StageAPI.CurrentStage = override.ReplaceWith
                    else
                        StageAPI.CurrentStage = StageAPI.NextStage
                    end

                    StageAPI.NextStage = nil
                end
            else
                if StageAPI.CurrentStage and room:GetType() == RoomType.ROOM_DEFAULT then
                    if not currentRoom then
                        local newRoom = {}
                        setmetatable(newRoom, {__index = function(tbl, k)
                            return tbl.Layout[k]
                        end})

                        local callbacks = StageAPI.GetCallbacks("PRE_GENERATE_ROOM")
                        local layoutOverride
                        for _, callback in ipairs(callbacks) do
                            local ret = callback.Function()
                            if ret then
                                layoutOverride = ret
                                break
                            end
                        end

                        newRoom.Layout = layoutOverride or StageAPI.GenerateRoom(StageAPI.CurrentStage.Rooms.ByShape, false, true)

                        for i = 0, 7 do
                            local door = room:GetDoor(i)
                            if door then
                                door:Close()
                            end
                        end

                        newRoom.WasClearAtStart = room:IsClear()
                        newRoom.IsClear = newRoom.WasClearAtStart

                        local callbacks = StageAPI.GetCallbacks("POST_GENERATE_ROOM")
                        for _, callback in ipairs(callbacks) do
                            callback.Function(newRoom, false)
                        end

                        currentRoom = newRoom
                        StageAPI.LevelRooms[currentListIndex] = newRoom
                    else
                        StageAPI.GenerateRoom(nil, currentRoom.IsClear, false, currentRoom.Layout)

                        local callbacks = StageAPI.GetCallbacks("POST_GENERATE_ROOM")
                        for _, callback in ipairs(callbacks) do
                            callback.Function(currentRoom, true)
                        end

                        for i = 0, 7 do
                            local door = room:GetDoor(i)
                            if door then
                                door:Close()
                            end
                        end
                    end
                end
            end

            if StageAPI.InNewStage() and room:GetType() == RoomType.ROOM_BOSS then

            end

            local rtype
            if currentRoom and currentRoom.TypeOverride then
                rtype = currentRoom.TypeOverride
            else
                rtype = room:GetType()
            end

            if StageAPI.CurrentStage.RoomGfx[rtype] then
                local callbacks = StageAPI.GetCallbacks("PRE_CHANGE_ROOM_GFX")
                local gfxOverride
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function()
                    if ret ~= nil then
                        gfxOverride = ret
                    end
                end

                if gfxOverride == nil then
                    StageAPI.ChangeRoomGfx(StageAPI.CurrentStage.RoomGfx[rtype])
                elseif gfxOverride ~= false then
                    StageAPI.ChangeRoomGfx(gfxOverride)
                end

                local callbacks = StageAPI.GetCallbacks("POST_CHANGE_ROOM_GFX")
                for _, callback in ipairs(callbacks) do
                    callback.Function()
                end
            end
        else
            if room:GetBackdropType() == 5 then
                StageAPI.ChangeRoomGfx(StageAPI.CatacombsRoomGfx)
                StageAPI.OldBackdropType = 5
            end

            StageAPI.ChangeShading("_default")
        end
    end)

    mod:AddCallback(ModCallbacks.MC_EXECUTE_CMD, function(_, cmd, params)
        if cmd == "cstage" and StageAPI.CustomStages[params] then
            StageAPI.NextStage = StageAPI.CustomStages[params]
            Isaac.ExecuteCommand("stage 3a")
        end
    end)
end

StageAPI.Loaded = true
if StageAPI.ToCall then
    for _, fn in ipairs(StageAPI.ToCall) do
        fn()
    end
end
