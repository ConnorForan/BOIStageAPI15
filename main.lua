local mod = RegisterMod("StageAPI", 1)

--[[ FUNCTIONALITY

- RoomsList - object containing room filenames and the require()d files.
-- RoomsList(roomfile, roomfile, roomfile)

- Backdrop - object containing backdrop filenames (not a real object, just a way of setting a table up that you need to do)
{
    NFloors = {file},
    LFloors = {file, file},
    Corners = {file},
    Walls = {file, file, file}
}

- Grids - object containing grid filenames
-- SetRocks(filename)
-- SetBridges(filename)
-- SetPits(filename)
-- SetDecorations(filename)
-- SetDoors(filename, targetType, currentType, targetNot, currentNot) -- target / current type can be nil for any

- RoomGfx - object containing Backdrop & Grid Entity gfx.
-- RoomGfx(backdrop, grids)
-- SetRoomGfx(RoomGfx) -- loads all grids & backdrop
-- Can be assigned to RoomTypes as well, for boss rooms, challenge rooms, etc. Assign multiple for random choice.

- CustomStage
-- SetRoomGfx(RoomGfx, RoomType)
-- SetRoomMusic(Music, RoomType)
-- SetRooms(RoomsList)
-- SetEndStage(stage, custom) -- where this stage will output you, "stage" can be a CustomStage or a LevelStage, interpretation based on "custom" bool. This is to be used for multi stage floors.
-- SetName(name) -- string that is automatically rendered on stage enter, like "Glacier 1" or "Glacer 2"
-- Duplicate() -- clones the stage. Useful for multi stage floors, to duplicate, make changes, then pass into SetEndStage of the first.
-- SetBosses(bosses)

- Bosses - object containing boss information (not a real object, just a way of setting a table up that you need to do)
{
    {
        Name = "", -- Used for identification / to set encounters
        NameTwo = "", -- when setting if a boss has been encountered, will set NameTwo's as well
        Portrait = "",
        Bossname = "", -- name sprite rather than ID name
        Rooms = RoomsList,
        Shapes = {RoomShape, RoomShape}, -- optional, autogenerated from list if not specified.
        Portrait2 = "", -- used for double trouble
        Weight = 1,
        Horseman = false -- in boss selection, if a horseman boss already exists in the boss room and there is a boss for the floor with the Horseman flag set, picks that boss.
    },
    ...
}

- CustomRoom (mostly internal class, but accessible)
-- Name
-- Filename
-- Layout
-- RoomGfx
-- ListIndex
-- IsCleared
-- Load(doEnemies, doGrids)
-- TypeOverride -- Not normally set, can be to change how Grid, Backdrop, and Music work.

- Basic Internal
-- Class(Type) -- returns an object that can be called with () to instantiate an object with metatable __index set to the original, then calling functions named init.
-- AddCallback(id, priority, fn, ...) -- higher priority = sooner
--- PRE_ROOM_SELECT(rooms) -- return room to force it to spawn and cancel other callbacks, doesn't have to be one of the rooms the api is choosing
--- PRE_ROOM_LOAD(layout, doEnemies, doGrids) -- return false to cancel other callbacks and prevent layout from spawning
--- PRE_ROOM_GRAPHICS_LOAD() -- return false to cancel other callbacks and prevent graphics from loading
--- POST_ROOM_LOAD()
--- PRE_ROOM_ENTER(reentered) -- called when entering room, before selection, load, gfx, etc. Return false to cancel all load. Good for custom special rooms that shouldn't act the same way as the floor.
--- POST_ROOM_ENTER(reentered) -- called when entering room, after selection, load, gfx
--- PRE_SPAWN_ENTRY(entry, isGrid) -- return false or a new entry to cancel / change
--- POST_SPAWN_ENTRY(spawned, isGrid, entry)
--- PRE_BOSS_SELECT(bosses) -- return boss to force it to spawn and cancel other callbacks, doesn't have to be one of the rooms the api is choosing
--- PRE_BOSS_ANIMATION_PLAY(name, portrait, bossname) -- return false or new name, portrait, and bossname to cancel / change

- Basic External
-- SetCustomStage(CustomStage) -- go to a custom stage
-- ChangeGrids(grids)
-- ChangeBackdrop(backdrop[s]) -- if multiple backdrops are passed in a table, select a random "variant". nfloors, walls, etc selected at random from that variant's lists.
-- ChangeRoomLayout(RoomsList)
-- GetCurrentRoom()
-- GetRoomAtListIndex(listindex)
]]

if not StageAPI then
    StageAPI = {}
end

setmetatable(StageAPI, {
    __index = function(tbl, ind)
        if ind == "Room" then
            tbl.Room = tbl.Game:GetRoom()
            return tbl.Room
        elseif ind == "Level" then
            tbl.Level = tbl.Game:GetLevel()
            return tbl.Level
        end
    end
})

StageAPI.Game = Game()
StageAPI.Players = {}

if Isaac.GetPlayer(0) then
    StageAPI.Room = StageAPI.Game:GetRoom()
    StageAPI.Level = StageAPI.Game:GetLevel()
    local numPlayers = StageAPI.Game:GetNumPlayers()
    if numPlayers > 0 then
        for i = 1, numPlayers do
            StageAPI.Players[i] = Isaac.GetPlayer(i - 1)
        end
    end
end

StageAPI.ZeroVector = Vector(0, 0)

mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, function()
    StageAPI.Level = StageAPI.Game:GetLevel()
    StageAPI.Room = StageAPI.Game:GetRoom()
    for i = 1, StageAPI.Game:GetNumPlayers() do
        StageAPI.Players[i] = Isaac.GetPlayer(i - 1)
    end
end)


mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
    StageAPI.Level = StageAPI.Game:GetLevel()
    StageAPI.Room = StageAPI.Game:GetRoom()
end)

local game, room, level, players, zeroVector = StageAPI.Game, StageAPI.Room, StageAPI.Level, StageAPI.Players, StageAPI.ZeroVector

mod:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, function(_, shouldSave)
    StageAPI.Players = {}
end)

StageAPI.E = {
    Backdrop = "StageAPIBackdrop",
    Bridge = "StageAPIBridge",
    Shading = "StageAPIShading"
}

for k, v in pairs(StageAPI.E) do
    StageAPI.E[k] = {
        T = Isaac.GetEntityTypeByName(v),
        V = Isaac.GetEntityVariantByName(v)
    }
end

StageAPI.RandomRNG = RNG()
StageAPI.RandomRNG:SetSeed(Random(), 0)
function StageAPI.Random(min, max, rng)
    rng = rng or StageAPI.RandomRNG
    if min and max then
        return math.floor(rng:RandomFloat() * (max - min + 1) + min)
    elseif min ~= nil then
        return math.floor(rng:RandomFloat() * (min + 1))
    end
    return rng:RandomFloat()
end

function StageAPI.WeightedRNG(args, rng, key, preCalculatedWeight) -- takes tables {{obj, weight}, {"pie", 3}, {555, 0}}
    local weight_value = preCalculatedWeight or 0
    local iterated_weight = 1
    if not preCalculatedWeight then
        for _, potentialObject in ipairs(args) do
            if key then
                weight_value = weight_value + potentialObject[key]
            else
                weight_value = weight_value + potentialObject[2]
            end
        end
    end

    local random_chance = StageAPI.Random(1, weight_value, rng)
    for i, potentialObject in ipairs(args) do
        if key then
            iterated_weight = iterated_weight + potentialObject[key]
        else
            iterated_weight = iterated_weight + potentialObject[2]
        end

        if iterated_weight > random_chance then
            local ret = potentialObject
            if key then
                return ret, i
            else
                return ret[1], i
            end
        end
    end
end

function StageAPI.Class(Type)
    local newClass = {}
    setmetatable(newClass, {
        __call = function(tbl, ...)
            local inst = {}
            setmetatable(inst, {
                __index = tbl
            })
            if inst.Init then
                inst:Init(...)
            end

            if inst.PostInit then
                inst:PostInit(...)
            end

            inst.Type = Type

            return inst
        end
    })
    return newClass
end

StageAPI.Callbacks = {}

local function Reverse_Iterator(t,i)
  i=i-1
  local v=t[i]
  if v==nil then return v end
  return i,v
end

function StageAPI.ReverseIterate(t)
    return Reverse_Iterator, t, #t+1
end

function StageAPI.AddCallback(id, priority, fn, ...)
    if not StageAPI.Callbacks[id] then
        StageAPI.Callbacks[id] = {}
    end

    local index = #StageAPI.Callbacks[id] + 1

    for i, callback in StageAPI.ReverseIterate(StageAPI.Callbacks[id]) do
        if callback.Priority > priority then
            index = i + 1
            break
        end
    end

    table.insert(StageAPI.Callbacks[id], index, {
        Priority = priority,
        Function = fn,
        Params = {...}
    })
end

function StageAPI.GetCallbacks(id)
    return StageAPI.Callbacks[id] or {}
end

function StageAPI.CallCallbacks(id, breakOnFirstReturn, ...)
    for _, callback in ipairs(StageAPI.GetCallbacks(id)) do
        local ret = callback.Function(...)
        if breakOnFirstReturn and ret ~= nil then
            return ret
        end
    end
end

function StageAPI.IsIn(tbl, v, fn)
    fn = fn or ipairs
    for k, v2 in fn(tbl) do
        if v2 == v then
            return k or true
        end
    end
end

function StageAPI.GetPlayingAnimation(sprite, animations)
    for _, anim in ipairs(animations) do
        if sprite:IsPlaying(anim) then
            return anim
        end
    end
end

function StageAPI.VectorToGrid(x, y, width)
    width = width or room:GetGridWidth()
    return width + 1 + (x + width * y)
end

function StageAPI.GridToVector(index, width)
    width = width or room:GetGridWidth()
    return (index % width) - 1, (math.floor(index / width)) - 1
end

function StageAPI.GetScreenCenterPosition()
    local centerOffset = (room:GetCenterPos()) - room:GetTopLeftPos()
    local pos = room:GetCenterPos()
    if centerOffset.X > 260 then
		pos.X = pos.X - 260
    end
    if centerOffset.Y > 140 then
        pos.Y = pos.Y - 140
    end
    return Isaac.WorldToRenderPosition(pos, false)
end

function StageAPI.GetScreenBottomRight()
	return StageAPI.GetScreenCenterPosition() * 2
end

StageAPI.CorrectedGridTypes = {
    [1000]=GridEntityType.GRID_ROCK,
    [1001]=GridEntityType.GRID_ROCK_BOMB,
    [1002]=GridEntityType.GRID_ROCK_ALT,
    [1300]=GridEntityType.GRID_TNT,
    [1497]=GridEntityType.GRID_POOP,
    [1496]=GridEntityType.GRID_POOP,
    [1495]=GridEntityType.GRID_POOP,
    [1494]=GridEntityType.GRID_POOP,
    [1490]=GridEntityType.GRID_POOP,
    [1500]=GridEntityType.GRID_POOP,
    [1900]=GridEntityType.GRID_ROCKB,
    [1930]=GridEntityType.GRID_SPIKES,
    [1931]=GridEntityType.GRID_SPIKES_ONOFF,
    [1940]=GridEntityType.GRID_SPIDERWEB,
    [3000]=GridEntityType.GRID_PIT,
    [4000]=GridEntityType.GRID_LOCK,
    [4500]=GridEntityType.GRID_PRESSURE_PLATE,
    [9000]=GridEntityType.GRID_TRAPDOOR,
    [9100]=GridEntityType.GRID_STAIRS,
    [10000]=GridEntityType.GRID_GRAVITY
}

Isaac.DebugString("[StageAPI] Loading Overlay System")
do -- Overlays
    StageAPI.DebugTiling = false
    function StageAPI.RenderSpriteTiled(sprite, position, size, centerCorrect)
        local screenBottomRight = StageAPI.GetScreenBottomRight()
        local screenFitX = screenBottomRight.X / size.X
        local screenFitY = screenBottomRight.Y / size.Y
        local timesRendered = 0
        for x = -1, math.ceil(screenFitX) do
            for y = -1, math.ceil(screenFitY) do
                local pos = position + Vector(size.X * x, size.Y * y)
                if centerCorrect then
                    pos = pos + Vector(
                        size.X * x,
                        size.Y * y
                    )
                end

                sprite:Render(pos, zeroVector, zeroVector)
                if StageAPI.DebugTiling then
                    timesRendered = timesRendered + 1
                    Isaac.RenderText("RenderPoint (" .. tostring(timesRendered) .. "): " .. tostring(x) .. ", " .. tostring(y), pos.X, pos.Y, 255, 0, 0, 1)
                end
            end
        end
    end

    StageAPI.OverlayDefaultSize = Vector(512, 512)
    StageAPI.Overlay = StageAPI.Class("Overlay")
    function StageAPI.Overlay:Init(file, velocity, offset, size)
        self.Sprite = Sprite()
        self.Sprite:Load(file, true)
        self.Sprite:Play("Idle", true)
        self.Position = zeroVector
        self.Velocity = velocity or zeroVector
        self.Offset = offset or zeroVector
        self.Size = size or StageAPI.OverlayDefaultSize
    end

    function StageAPI.Overlay:SetAlpha(alpha, noCancelFade)
        local sprite = self.Sprite
        sprite.Color = Color(sprite.Color.R, sprite.Color.G, sprite.Color.B, alpha, math.floor(sprite.Color.RO*255), math.floor(sprite.Color.GO*255), math.floor(sprite.Color.BO*255))
        if not noCancelFade then
            self.FadeTime = nil
            self.FadeTotal = nil
            self.FadeStep = nil
        end
    end

    function StageAPI.Overlay:Fade(total, time, step) -- use a step of -1 to fade out
        step = step or 1
        self.FadeTotal = total
        self.FadeTime = time
        self.FadeStep = step
    end

    function StageAPI.Overlay:Render(centerCorrect)
        centerCorrect = not centerCorrect
        if self.FadeTime and self.FadeTotal and self.FadeStep then
            self.FadeTime = self.FadeTime + self.FadeStep
            if self.FadeTime < 0 then
                self.FadeTime = 0
            end

            if self.FadeTime > self.FadeTotal then
                self.FadeTime = self.FadeTotal
            end

            self:SetAlpha(self.FadeTime / self.FadeTotal, true)
        end

        if self.Velocity then
            self.Position = self.Position + self.Velocity
            if self.Position.X >= self.Size.X then
                self.Position = Vector(0, self.Position.Y)
            end

            if self.Position.Y >= self.Size.Y then
                self.Position = Vector(self.Position.X, 0)
            end

            if self.Position.X < 0 then
                self.Position = Vector(self.Size.X, self.Position.Y)
            end

            if self.Position.Y < 0 then
                self.Position = Vector(self.Position.X, self.Size.Y)
            end
        end

        StageAPI.RenderSpriteTiled(self.Sprite, self.Position + (self.Offset or zeroVector), self.Size, centerCorrect)
    end
end

Isaac.DebugString("[StageAPI] Loading Room Handler")
do -- RoomsList
    function StageAPI.SimplifyRoomLayout(layout)
        local outLayout = {
            GridEntities = {},
            Entities = {},
            EntitiesByIndex = {},
            Doors = {},
            Shape = layout.SHAPE,
            Weight = layout.WEIGHT,
            Difficulty = layout.DIFFICULTY,
            Name = layout.NAME,
            Width = layout.WIDTH + 2,
            Height = layout.HEIGHT + 2,
            Type = layout.TYPE,
            Variant = layout.VARIANT,
            SubType = layout.SUBTYPE
        }

        for _, object in ipairs(layout) do
            if not object.ISDOOR then
                if StageAPI.CorrectedGridTypes[object[1].TYPE] then
                    outLayout.GridEntities[#outLayout.GridEntities + 1] = {
                        Type = StageAPI.CorrectedGridTypes[object[1].TYPE],
                        Variant = object[1].VARIANT,
                        GridX = object.GRIDX,
                        GridY = object.GRIDY,
                        Index = StageAPI.VectorToGrid(object.GRIDX, object.GRIDY, outLayout.Width)
                    }
                elseif object[1].TYPE ~= 0 then
                    local entData = {
                        Type = object[1].TYPE,
                        Variant = object[1].VARIANT,
                        SubType = object[1].SUBTYPE,
                        GridX = object.GRIDX,
                        GridY = object.GRIDY,
                        Index = StageAPI.VectorToGrid(object.GRIDX, object.GRIDY, outLayout.Width)
                    }

                    if entData.Type == 1400 or entData.Type == 1410 then
                        entData.Type = EntityType.ENTITY_FIREPLACE
                    end

                    if not outLayout.EntitiesByIndex[entData.Index] then
                        outLayout.EntitiesByIndex[entData.Index] = {}
                    end

                    outLayout.EntitiesByIndex[entData.Index][#outLayout.EntitiesByIndex[entData.Index] + 1] = entData
                    outLayout.Entities[#outLayout.Entities + 1] = entData
                end
            else
                outLayout.Doors[#outLayout.Doors + 1] = {
                    Slot = object.SLOT,
                    Exists = object.EXISTS
                }
            end
        end

        return outLayout
    end

    StageAPI.RoomsLists = {}
    StageAPI.RoomsList = StageAPI.Class("RoomsList")
    function StageAPI.RoomsList:Init(name, ...)
        self.Name = name
        StageAPI.RoomsLists[name] = self
        self.All = {}
        self.ByShape = {}
        self.Shapes = {}
        self:AddRooms(...)
    end

    function StageAPI.RoomsList:AddRooms(...)
        local roomfiles = {...}
        for _, rooms in ipairs(roomfiles) do
            local roomfile = "N/A"
            if rooms.Name and rooms.Rooms then
                roomfile = rooms.Name
                rooms = rooms.Rooms
            end

            for _, room in ipairs(rooms) do
                local simplified = StageAPI.SimplifyRoomLayout(room)
                simplified.RoomFilename = roomfile
                self.All[#self.All + 1] = simplified
                if not self.ByShape[simplified.Shape] then
                    self.Shapes[#self.Shapes + 1] = simplified.Shape
                    self.ByShape[simplified.Shape] = {}
                end

                self.ByShape[simplified.Shape][#self.ByShape[simplified.Shape] + 1] = simplified
            end
        end
    end

    function StageAPI.ClearRoomLayout(keepDecoration, doGrids, doEnts, doPersistentEnts)
        if doEnts or doPersistentEnts then
            for _, ent in ipairs(Isaac.GetRoomEntities()) do
                local etype = ent.Type
                if etype ~= EntityType.ENTITY_FAMILIAR and etype ~= EntityType.ENTITY_PLAYER and etype ~= EntityType.ENTITY_KNIFE then
                    if not doPersistentEnts then
                        if ent:ToNPC() then
                            ent:Remove()
                        end
                    else
                        ent:Remove()
                    end
                end
            end
        end

        if doGrids then
            for i = 0, room:GetGridSize() do
                local grid = room:GetGridEntity(i)
                if grid then
                    local gtype = grid.Desc.Type
                    if gtype ~= GridEntityType.GRID_WALL and gtype ~= GridEntityType.GRID_DOOR then
                        StageAPI.Room:RemoveGridEntity(i, 0, keepDecoration)
                    end
                end
            end
        end

        room:Update()
    end

    StageAPI.RoomChooseRNG = RNG()
    function StageAPI.ChooseRoomLayout(roomList, seed, shape)
        local callbacks = StageAPI.GetCallbacks("CHECK_VALID_ROOM")
        local validRooms = {}

        shape = shape or room:GetRoomShape()
        local possibleRooms = roomList[shape]
        if possibleRooms then
            for _, layout in ipairs(possibleRooms) do
                local isValid = true
                for _, door in ipairs(layout.Doors) do
                    if door.Slot then
                        if door.Exists then
                            if not room:IsDoorSlotAllowed(door.Slot) then
                                isValid = false
                                break
                            end
                        else
                            if room:GetDoor(door.Slot) then
                                isValid = false
                                break
                            end
                        end
                    end
                end

                for _, callback in ipairs(callbacks) do
                    if callback.Function(roomList) == false then
                        isValid = false
                        break
                    end
                end

                if isValid then
                    validRooms[#validRooms + 1] = {layout, layout.Weight}
                end
            end
        end

        if #validRooms > 0 then
            StageAPI.RoomChooseRNG:SetSeed(room:GetSpawnSeed(), 0)
            return StageAPI.WeightedRNG(validRooms, StageAPI.RoomChooseRNG)
        end
    end

    StageAPI.PersistentEntities = {}
    function StageAPI.MakeEntityPersistent(etype, variant, subtype, autoPersists, removeOnRemove, removeOnDeath, updatePosition, storeCheck)
        StageAPI.PersistentEntities[#StageAPI.PersistentEntities + 1] = {
            Type = etype,
            Variant = variant,
            SubType = subtype,
            AutoPersists = autoPersists,
            RemoveOnRemove = removeOnRemove,
            RemoveOnDeath = removeOnDeath,
            UpdatePosition = updatePosition,
            StoreCheck = storeCheck
        }
    end

    StageAPI.PersistenceChecks = {}
    function StageAPI.AddPersistenceCheck(fn)
        StageAPI.PersistenceChecks[#StageAPI.PersistenceChecks + 1] = fn
    end

    StageAPI.MakeEntityPersistent(EntityType.ENTITY_STONEHEAD, nil, nil, nil, false, true, nil, false)
    StageAPI.MakeEntityPersistent(EntityType.ENTITY_BRIMSTONE_HEAD, nil, nil, nil, false, true, nil, false)
    StageAPI.MakeEntityPersistent(EntityType.ENTITY_STONE_EYE, nil, nil, nil, false, true, nil, false)
    StageAPI.MakeEntityPersistent(EntityType.ENTITY_CONSTANT_STONE_SHOOTER, nil, nil, nil, false, true, nil, false)

    StageAPI.AddPersistenceCheck(function(entData)
        if entData.Type <= 9 or entData.Type == EntityType.ENTITY_FIREPLACE then
            return {
                AutoPersists = true,
                UpdatePosition = true,
                RemoveOnRemove = true,
                StoreCheck = function(entity)
                    if entity.Type == EntityType.ENTITY_PICKUP then
                        local variant = entity.Variant
                        if variant == PickupVariant.PICKUP_COLLECTIBLE then
                            return entity.SubType == 0
                        else
                            local sprite = entity:GetSprite()
                            if sprite:IsPlaying("Open") or sprite:IsPlaying("Opened") or sprite:IsPlaying("Collect") then
                                return true
                            end

                            if entity:IsDead() then
                                return true
                            end
                        end
                    end
                end
            }
        end
    end)

    function StageAPI.CheckPersistence(id, variant, subtype)
        local persistentData
        for _, persistData in ipairs(StageAPI.PersistentEntities) do
            if (not persistData.Type or id == persistData.Type)
            and (not persistData.Variant or variant == persistData.Variant)
            and (not persistData.SubType or subtype == persistData.SubType) then
                persistentData = persistData
            end
        end

        if not persistentData then
            for _, check in ipairs(StageAPI.PersistenceChecks) do
                local persistData = check({Type = id, Variant = variant, SubType = subtype})
                if persistData then
                    persistentData = persistData
                    break
                end
            end
        end

        return persistentData
    end

    StageAPI.RoomLoadRNG = RNG()
    function StageAPI.SelectSpawnEntities(entities, seed)
        StageAPI.RoomLoadRNG:SetSeed(seed or room:GetSpawnSeed(), 1)
        local entitiesToSpawn = {}
        local callbacks = StageAPI.GetCallbacks("PRE_SELECT_ENTITY_LIST")
        local persistentIndex = 0
        for index, entityList in pairs(entities) do
            if #entityList > 0 then
                local addEntities = {}
                local overridden = false
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function(entityList, index)
                    if ret == false then
                        overridden = true
                        break
                    elseif ret and type(ret) == "table" then
                        addEntities = ret
                        overridden = true
                        break
                    end
                end

                if not overridden then
                    addEntities[#addEntities + 1] = entityList[StageAPI.Random(1, #entityList, StageAPI.RoomLoadRNG)]
                end

                if #addEntities > 0 then
                    if not entitiesToSpawn[index] then
                        entitiesToSpawn[index] = {}
                    end

                    for _, entData in ipairs(addEntities) do
                        persistentIndex = persistentIndex + 1

                        local persistentData = StageAPI.CheckPersistence(entData.Type, entData.Variant, entData.SubType)

                        entitiesToSpawn[index][#entitiesToSpawn[index] + 1] = {
                            Data = entData,
                            PersistentIndex = persistentIndex,
                            Persistent = not not persistentData,
                            PersistenceData = persistentData
                        }
                    end
                end
            end
        end

        return entitiesToSpawn, persistentIndex
    end

    function StageAPI.LoadEntitiesFromEntitySets(entitysets, doGrids, doPersistentOnly, doAutoPersistent, avoidSpawning, persistentPositions)
        local ents_spawned = {}
        local listCallbacks = StageAPI.GetCallbacks("PRE_SPAWN_ENTITY_LIST")
        local entCallbacks = StageAPI.GetCallbacks("PRE_SPAWN_ENTITY")
        if type(entitysets) ~= "table" then
            entitysets = {entitysets}
        end

        for _, entities in ipairs(entitysets) do
            for index, entityList in pairs(entities) do
                if #entityList > 0 then
                    local shouldSpawn = true
                    for _, callback in ipairs(listCallbacks) do
                        local ret = callback.Function(entityList, index, doGrids)
                        if ret == false then
                            shouldSpawn = false
                            break
                        elseif ret and type(ret) == "table" then
                            entityList = ret
                            break
                        end
                    end

                    if shouldSpawn and #entityList > 0 then
                        for _, entityInfo in ipairs(entityList) do
                            local shouldSpawnEntity = true
                            for _, callback in ipairs(entCallbacks) do
                                local ret = callback.Function(entityInfo, entityList, index, doGrids)
                                if ret == false then
                                    shouldSpawnEntity = false
                                    break
                                elseif ret and type(ret) == "table" then
                                    entityInfo = ret
                                    break
                                end
                            end

                            if shouldSpawnEntity and avoidSpawning and avoidSpawning[entityInfo.PersistentIndex] then
                                shouldSpawnEntity = false
                            end

                            if shouldSpawnEntity and doPersistentOnly and not entityInfo.PersistenceData then
                                shouldSpawnEntity = false
                            end

                            if shouldSpawnEntity and entityInfo.Persistent and entityInfo.PersistenceData.AutoPersists and not doAutoPersistent then
                                shouldSpawnEntity = false
                            end

                            if shouldSpawnEntity then
                                if entityInfo.PersistentIndex and persistentPositions and persistentPositions[entityInfo.PersistentIndex] then
                                    entityInfo.Position = Vector(persistentPositions[entityInfo.PersistentIndex].X, persistentPositions[entityInfo.PersistentIndex].Y)
                                end

                                if not entityInfo.Position then
                                    entityInfo.Position = room:GetGridPosition(index)
                                end

                                local entityData = entityInfo.Data
                                if doGrids or (entityData.Type > 9 and entityData.Type ~= EntityType.ENTITY_FIREPLACE) then
                                    local ent = Isaac.Spawn(
                                        entityData.Type or 20,
                                        entityData.Variant or 0,
                                        entityData.SubType or 0,
                                        entityInfo.Position or StageAPI.ZeroVector,
                                        StageAPI.ZeroVector,
                                        nil
                                    )

                                    if entityInfo.Persistent then
                                        ent:GetData().PersistentIndex = entityInfo.PersistentIndex
                                        ent:GetData().PersistenceData = entityInfo.PersistenceData
                                    end

                                    if ent:CanShutDoors() then
                                        StageAPI.Room:SetClear(false)
                                    end

                                    ents_spawned[#ents_spawned + 1] = ent
                                end
                            end
                        end
                    end
                end
            end
        end

        return ents_spawned
    end

    function StageAPI.CallGridPostInit()
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                grid:PostInit()
            end
        end
    end

    function StageAPI.LoadGridsFromDataList(grids, gridInformation)
        local grids_spawned = {}
        local callbacks = StageAPI.GetCallbacks("PRE_SPAWN_GRID")
        for _, gridData in ipairs(grids) do
            local shouldSpawn = true
            for _, callback in ipairs(callbacks) do
                local ret = callback.Function(gridData)
                if ret == false then
                    shouldSpawn = false
                    break
                end
            end

            local index = gridData.Index
            if shouldSpawn and StageAPI.Room:IsPositionInRoom(StageAPI.Room:GetGridPosition(index), 0) then
                room:RemoveGridEntity(index, 0, false)
                local grid = Isaac.GridSpawn(gridData.Type, gridData.Variant, StageAPI.Room:GetGridPosition(index), true)
                if grid then
                    if gridInformation and gridInformation[index] then
                        local grinformation = gridInformation[index]
                        if grinformation.State ~= nil then
                            grid.State = grinformation.State
                            if grinformation.State == 4 and gridData.Type == GridEntityType.GRID_TNT then
                                grid:ToTNT().FrameCnt = -1
                            end
                        end

                        if grinformation.VarData ~= nil then
                            grid.VarData = grinformation.VarData
                        end
                    end

                    grids_spawned[#grids_spawned + 1] = grid
                end
            end
        end

        return grids_spawned
    end

    function StageAPI.GetGridInformation()
        local gridInformation = {}
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                gridInformation[i] = {
                    State = grid.State,
                    VarData = grid.VarData
                }
            end
        end

        return gridInformation
    end

    function StageAPI.LoadRoomLayout(grids, entities, doGrids, doEntities, doPersistentOnly, doAutoPersistent, gridData, avoidSpawning, persistentPositions)
        local grids_spawned = {}
        local ents_spawned = {}

        if grids and doGrids then
            grids_spawned = StageAPI.LoadGridsFromDataList(grids, gridData)
        end

        StageAPI.Room:Update()

        if entities and doEntities then
            ents_spawned = StageAPI.LoadEntitiesFromEntitySets(entities, doGrids, doPersistentOnly, doAutoPersistent, avoidSpawning, persistentPositions)
        end

        StageAPI.CallGridPostInit()

        StageAPI.Room:Update()

        StageAPI.StoreRoomGrids()

        return ents_spawned, grids_spawned
    end

    StageAPI.ExtraRooms = {}
    function StageAPI.SetExtraRoom(name, room)
        StageAPI.ExtraRooms[name] = room
    end

    function StageAPI.GetExtraRoom(name)
        return StageAPI.ExtraRooms[name]
    end

    StageAPI.RoomTransitionOverlay = Sprite()
    StageAPI.RoomTransitionOverlay:Load("stageapi/overlay.anm2", false)
    StageAPI.RoomTransitionOverlay:ReplaceSpritesheet(0, "stageapi/overlay_black.png")
    StageAPI.RoomTransitionOverlay:Play("Idle", true)

    StageAPI.TransitionFadeTime = 10

    StageAPI.TransitionTimer = 0
    StageAPI.TransitioningTo = nil
    function StageAPI.TransitionToExtraRoom(name)
        StageAPI.TransitionTimer = 0
        StageAPI.TransitioningTo = StageAPI.GetExtraRoom(name)
    end

    StageAPI.RoomShapeToGotoID = {
        [RoomShape.ROOMSHAPE_1x1] = "4550",
        [RoomShape.ROOMSHAPE_IH] = "4551",
        [RoomShape.ROOMSHAPE_IV] = "4552",
        [RoomShape.ROOMSHAPE_1x2] = "4553",
        [RoomShape.ROOMSHAPE_IIV] = "4554",
        [RoomShape.ROOMSHAPE_2x1] = "4555",
        [RoomShape.ROOMSHAPE_IIH] = "4556",
        [RoomShape.ROOMSHAPE_2x2] = "4557",
        [RoomShape.ROOMSHAPE_LTL] = "4558",
        [RoomShape.ROOMSHAPE_LTR] = "4559",
        [RoomShape.ROOMSHAPE_LBL] = "4560",
        [RoomShape.ROOMSHAPE_LBR] = "4561"
    }

    mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
        if StageAPI.TransitioningTo then
            StageAPI.TransitionTimer = StageAPI.TransitionTimer + 1
            if StageAPI.TransitionTimer == StageAPI.TransitionFadeTime then
                local id = StageAPI.RoomShapeToGotoID[StageAPI.TransitioningTo.Shape]
                Isaac.ExecuteCommand("goto s.barren." .. id)
            end
        elseif StageAPI.TransitionTimer then
            StageAPI.TransitionTimer = StageAPI.TransitionTimer - 1
            if StageAPI.TransitionTimer <= 0 then
                StageAPI.TransitionTimer = nil
            end
        end

        if StageAPI.TransitionTimer then
            StageAPI.RoomTransitionOverlay.Color = Color(1, 1, 1, StageAPI.TransitionTimer / StageAPI.TransitionFadeTime, 0, 0, 0)
            StageAPI.RoomTransitionOverlay:Render(zeroVector, zeroVector, zeroVector)
        end
    end)

    mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
        if StageAPI.TransitioningTo then
            StageAPI.TransitioningTo:Load()
            StageAPI.TransitioningTo = nil
        end
    end)

    StageAPI.LevelRooms = {}
    function StageAPI.SetCurrentRoom(room)
        StageAPI.LevelRooms[StageAPI.GetCurrentListIndex()] = room
    end

    function StageAPI.GetCurrentRoom()
        return StageAPI.LevelRooms[StageAPI.GetCurrentListIndex()]
    end

    function StageAPI.GetRooms()
        return StageAPI.LevelRooms
    end

    function StageAPI.CloseDoors()
        for i = 0, 7 do
            local door = room:GetDoor(i)
            if door then
                door:Close()
            end
        end
    end

    StageAPI.LevelRoom = StageAPI.Class("LevelRoom")
    function StageAPI.LevelRoom:Init(layout, roomsList, seed, shape, roomType)
        roomType = roomType or room:GetType()
        shape = shape or room:GetRoomShape()
        seed = seed or room:GetSpawnSeed()
        if roomsList and not layout then
            layout = StageAPI.ChooseRoomLayout(roomsList, seed, shape)
        end

        self.Shape = shape
        self.Type = roomType
        self.Seed = seed
        self.RoomsListName = roomsList.Name
        self.SpawnEntities, self.LastPersistentIndex = StageAPI.SelectSpawnEntities(layout.EntitiesByIndex, seed)
        self.AvoidSpawning = {}
        self.ExtraSpawn = {}
        self.PersistentPositions = {}
        self.FirstLoad = true
        self.RoomType = roomType
        self.Layout = layout
    end

    function StageAPI.LevelRoom:SaveGridInformation()
        self.GridInformation = StageAPI.GetGridInformation()
    end

    function StageAPI.LevelRoom:SavePersistentEntities()
        for _, entity in ipairs(Isaac.GetRoomEntities()) do
            local data = entity:GetData()
            if data.PersistenceData then
                if data.PersistenceData.UpdatePosition then
                    data.PersistentPositions[data.PersistentIndex] = {X = entity.Position.X, Y = entity.Position.Y}
                end

                if data.PersistenceData.StoreCheck(entity, data) then
                    self.AvoidSpawning[data.PersistentIndex] = true
                end
            else
                local persistentData = StageAPI.CheckPersistence(entity.Type, entity.Variant, entity.SubType)
                if persistentData then
                    local index = self.LastPersistentIndex + 1
                    self.LastPersistentIndex = index
                    local grindex = room:GetGridIndex(entity.Position)
                    if not self.ExtraSpawn[grindex] then
                        self.ExtraSpawn[grindex] = {}
                    end

                    self.ExtraSpawn[grindex][#self.ExtraSpawn[grindex] + 1] = {
                        Data = {
                            Type = entity.Type,
                            Variant = entity.Variant,
                            SubType = entity.SubType,
                            Index = grindex
                        },
                        PersistentIndex = index,
                        PersistenceData = persistentData
                    }

                    if persistentData.UpdatePosition then
                        data.PersistentPositions[index] = {X = entity.Position.X, Y = entity.Position.Y}
                    end
                end
            end
        end
    end

    function StageAPI.LevelRoom:RemovePersistentIndex(persistentIndex)
        self.AvoidSpawning[persistentIndex] = true
    end

    function StageAPI.LevelRoom:RemovePersistentEntity(entity)
        local data = entity:GetData()
        if data.PersistenceData then
            self:RemovePersistentIndex(data.PersistentIndex)
        end
    end

    function StageAPI.LevelRoom:Load(isExtraRoom)
        StageAPI.ClearRoomLayout(false, self.FirstLoad or isExtraRoom, true)
        if self.FirstLoad then
            StageAPI.LoadRoomLayout(self.Layout.GridEntities, {self.SpawnEntities, self.ExtraSpawn}, true, true, false, true, self.GridInformation, self.AvoidSpawning, self.PersistentPositions)
            StageAPI.CloseDoors()
            self.WasClearAtStart = room:IsClear()
            self.IsClear = self.WasClearAtStart
            self.FirstLoad = false
        else
            StageAPI.LoadRoomLayout(self.Layout.GridEntities, {self.SpawnEntities, self.ExtraSpawn}, isExtraRoom, true, self.IsClear, isExtraRoom, self.GridInformation, self.AvoidSpawning, self.PersistentPositions)
            StageAPI.CloseDoors()
            self.IsClear = room:IsClear()
        end
    end

    function StageAPI.RemovePersistentEntity(entity)
        StageAPI.GetCurrentRoom():RemovePersistentEntity(entity)
    end

    mod:AddCallback(ModCallbacks.MC_POST_ENTITY_REMOVE, function(_, ent)
        local data = ent:GetData()
        if data.PersistenceData and data.PersistenceData.RemoveOnRemove then
            StageAPI.RemovePersistentEntity(ent)
        end
    end)

    mod:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, function(_, ent)
        local data = ent:GetData()
        if data.PersistenceData and data.PersistenceData.RemoveOnDeath then
            StageAPI.RemovePersistentEntity(ent)
        end
    end)
end

Isaac.DebugString("[StageAPI] Loading GridGfx Handler")
do -- GridGfx
    StageAPI.GridGfx = StageAPI.Class("GridGfx")
    function StageAPI.GridGfx:SetRocks(filename)
        self.Rocks = filename
    end

    function StageAPI.GridGfx:SetGrid(filename, t, v)
        if not self.Grids then
            self.Grids = {}
            self.GridsByVariant = {}
        end

        if v then
            self.GridsByVariant[t] = {
                [v] = filename
            }
        else
            self.Grids[t] = filename
        end
    end

    function StageAPI.GridGfx:SetPits(filename, alt)
        self.Pits = filename
        self.AltPits = alt
    end

    function StageAPI.GridGfx:SetBridges(filename)
        self.Bridges = filename
    end

    function StageAPI.GridGfx:SetDecorations(filename)
        self.Decorations = filename
    end

    StageAPI.PoopVariant = {
        Normal = 0,
        Red = 1,
        Eternal = 2,
        Golden = 3,
        Black = 4
    }

    -- No SetPoop, do GridGfx:SetGrid(filename, GridEntityType.GRID_POOP, StageAPI.PoopVariant.Normal)

    StageAPI.DefaultDoorSpawn = {
        RequireCurrent = {RoomType.ROOM_DEFAULT, RoomType.ROOM_MINIBOSS, RoomType.ROOM_SACRIFICE, RoomType.ROOM_SHOP, RoomType.ROOM_LIBRARY},
        RequireTarget = {RoomType.ROOM_DEFAULT, RoomType.ROOM_MINIBOSS, RoomType.ROOM_SACRIFICE, RoomType.ROOM_SHOP, RoomType.ROOM_LIBRARY}
    }

    StageAPI.SecretDoorSpawn = {
        RequireTarget = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET},
        NotCurrent = {RoomType.ROOM_SECRET, RoomType.ROOM_SUPERSECRET}
    }
    --[[
    DoorInfo
    {
        RequireCurrent = {},
        RequireTarget = {},
        RequireEither = {},
        NotCurrent = {},
        NotTarget = {},
        NotEither = {}
    }
    ]]
    function StageAPI.GridGfx:AddDoors(filename, doorInfo)
        self.Doors = self.Doors or {}
        doorInfo.File = filename
        self.Doors[#self.Doors + 1] = doorInfo
    end

    function StageAPI.GridGfx:SetPayToPlayDoor(filename)
        self.PayToPlayDoor = filename
    end


    StageAPI.RockAnimationMap = {
        "normal",
        "black",
        "tinted",
        "alt",
        "bombrock",
        "big",
        "superspecial",
        "ss_broken"
    }

    StageAPI.RockSprite = Sprite()
    StageAPI.RockSprite:Load("gfx/grid/grid_rock.anm2", true)
    function StageAPI.ChangeRock(rock, filename)
        local grid = rock.Grid:ToRock()

        for i = 0, 4 do
            StageAPI.RockSprite:ReplaceSpritesheet(i, filename)
        end
        StageAPI.RockSprite:LoadGraphics()

        grid.Sprite = StageAPI.RockSprite
        grid.Sprite:Play(grid.Anim, true)
        grid:UpdateAnimFrame()
    end

    StageAPI.BridgeEntities = {}
    mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
        StageAPI.BridgeEntities = {}
    end)

    StageAPI.BridgeOffset = Vector(3, 3)

    function StageAPI.CheckBridge(grid, index, bridgefilename)
        if grid.State == 1 and bridgefilename and not StageAPI.BridgeEntities[index] then
            local bridge = Isaac.Spawn(StageAPI.E.Bridge.T, StageAPI.E.Bridge.V, 0, room:GetGridPosition(index), zeroVector, nil)
            local sprite = bridge:GetSprite()
            sprite:Load("stageapi/bridge.anm2", false)
            sprite:ReplaceSpritesheet(0, bridgefilename)
            sprite:LoadGraphics()

            bridge:AddEntityFlags(EntityFlag.FLAG_DONT_OVERWRITE)
            bridge.SpriteOffset = StageAPI.BridgeOffset
            bridge.RenderZOffset = -10000
            StageAPI.BridgeEntities[index] = bridge
        end
    end

    StageAPI.PitSprite = Sprite()
    StageAPI.PitSprite:Load("gfx/grid/grid_pit.anm2", true)
    function StageAPI.ChangePit(pit, filename, bridgefilename, alt)
        local grid = pit.Grid

        if alt and room:HasWaterPits() then
            StageAPI.PitSprite:ReplaceSpritesheet(0, alt)
        else
            StageAPI.PitSprite:ReplaceSpritesheet(0, filename)
        end

        StageAPI.PitSprite:LoadGraphics()

        grid.Sprite = StageAPI.PitSprite

        StageAPI.CheckBridge(grid, pit.Index, bridgefilename)
    end

    StageAPI.DecorationSprite = Sprite()
    StageAPI.DecorationSprite:Load("gfx/grid/props_03_caves.anm2", true)
    StageAPI.DecorationRNG = RNG()
    function StageAPI.ChangeDecoration(decoration, filename)
        local grid = decoration.Grid

        StageAPI.DecorationSprite:ReplaceSpritesheet(0, filename)
        StageAPI.DecorationSprite:LoadGraphics()
        StageAPI.DecorationRNG:SetSeed(room:GetDecorationSeed(), decoration.Index)

        local prop = StageAPI.Random(1, 42, StageAPI.DecorationRNG)
        if prop < 10 then
            prop = "0" .. tostring(prop)
        end

        StageAPI.DecorationSprite:Play("Prop" .. tostring(prop), true)
        grid.Sprite = StageAPI.DecorationSprite
    end

    StageAPI.DoorAnimationMap = {
        "Opened",
        "Closed",
        "Open",
        "Close",
        "Break",
        "KeyOpen",
        "KeyClose",
        "BrokenOpen",
        "KeyClosed",
        "Hidden",
        "GoldenKeyOpen",
        "KeyOpenNoKey",
        "GoldKeyOpen",
        "ArcadeSign"
    }

    StageAPI.DoorSprite = Sprite()
    function StageAPI.ChangeDoor(door, doors, payToPlay)
        local grid = door.Grid:ToDoor()
        local current = grid.CurrentRoomType
        local target = grid.TargetRoomType
        local isPayToPlay = grid:IsTargetRoomArcade() and target ~= RoomType.ROOM_ARCADE

        if isPayToPlay then
            if payToPlay then
                local sprite = grid.Sprite
                for i = 0, 5 do
                    sprite:ReplaceSpritesheet(i, payToPlay)
                end

                sprite:LoadGraphics()

                grid.Sprite = sprite
            end

            return
        end

        for _, doorOption in ipairs(doors) do
            local valid = true
            if doorOption.RequireCurrent then
                local has = false
                for _, roomType in ipairs(doorOption.RequireCurrent) do
                    if current == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.RequireTarget then
                local has = false
                for _, roomType in ipairs(doorOption.RequireTarget) do
                    if target == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.RequireEither then
                local has = false
                for _, roomType in ipairs(doorOption.RequireEither) do
                    if current == roomType or target == roomType then
                        has = true
                    end
                end

                if not has then
                    valid = false
                end
            end

            if doorOption.NotCurrent then
                local has = false
                for _, roomType in ipairs(doorOption.NotCurrent) do
                    if current == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if doorOption.NotTarget then
                local has = false
                for _, roomType in ipairs(doorOption.NotTarget) do
                    if target == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if doorOption.NotEither then
                local has = false
                for _, roomType in ipairs(doorOption.NotEither) do
                    if current == roomType or target == roomType then
                        has = true
                    end
                end

                if has then
                    valid = false
                end
            end

            if valid then
                local sprite = grid.Sprite
                for i = 0, 5 do
                    sprite:ReplaceSpritesheet(i, doorOption.File)
                end

                sprite:LoadGraphics()

                grid.Sprite = sprite

                break
            end
        end
    end

    StageAPI.GridGfxAltRNG = RNG()
    function StageAPI.ChangeGrid(sent, filename)
        local grid = sent.Grid
        local sprite = grid.Sprite

        if type(filename) == "table" then
            StageAPI.GridGfxAltRNG:SetSeed(room:GetDecorationSeed(), sent.Index)
            filename = filename[StageAPI.Random(1, #filename, StageAPI.GridGfxAltRNG)]
        end

        sprite:ReplaceSpritesheet(0, filename)
        sprite:LoadGraphics()
        grid.Sprite = sprite
    end

    function StageAPI.ChangeSingleGrid(grid, grids, i)
        local desc = grid.Desc
        local gtype = desc.Type
        local send = {Grid = grid, Index = i, Type = gtype, Desc = desc}
        if gtype == GridEntityType.GRID_DOOR and grids.Doors then
            StageAPI.ChangeDoor(send, grids.Doors, grids.PayToPlayDoor)
        elseif grid:ToRock() and grids.Rocks then
            StageAPI.ChangeRock(send, grids.Rocks)
        elseif gtype == GridEntityType.GRID_PIT and grids.Pits then
            StageAPI.ChangePit(send, grids.Pits, grids.Bridges, grids.AltPits)
        elseif gtype == GridEntityType.GRID_DECORATION and grids.Decorations then
            StageAPI.ChangeDecoration(send, grids.Decorations)
        elseif grids.Grids or grids.GridsByVariant then
            local variant = send.Desc.Variant
            if grids.GridsByVariant and grids.GridsByVariant[send.Type] and grids.GridsByVariant[send.Type][variant] then
                StageAPI.ChangeGrid(send, grids.GridsByVariant[send.Type][variant])
            elseif grids.Grids and grids.Grids[send.Type] then
                StageAPI.ChangeGrid(send, grids.Grids[send.Type])
            end
        end
    end

    function StageAPI.ChangeGrids(grids)
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                StageAPI.ChangeSingleGrid(grid, grids, i)
            end
        end

        StageAPI.CallGridPostInit()
    end
end

Isaac.DebugString("[StageAPI] Loading Backdrop & RoomGfx Handling")
do -- Backdrop & RoomGfx
    StageAPI.BackdropRNG = RNG()
    local backdropDefaultOffset = Vector(260,0)
    local backdropIvOffset = Vector(113,0)
    local lRooms = {
        RoomShape.ROOMSHAPE_LTL,
        RoomShape.ROOMSHAPE_LTR,
        RoomShape.ROOMSHAPE_LBL,
        RoomShape.ROOMSHAPE_LBR
    }

    for _, roomsh in ipairs(lRooms) do
        lRooms[roomsh] = true
    end

    function StageAPI.ChangeBackdrop(backdrop)
        StageAPI.BackdropRNG:SetSeed(room:GetDecorationSeed(), 1)
        local roomShape = room:GetRoomShape()
        local backdropEntity = Isaac.Spawn(StageAPI.E.Backdrop.T, StageAPI.E.Backdrop.V, 0, zeroVector, zeroVector, nil)
        local sprite = backdropEntity:GetSprite()
        sprite:Load("stageapi/Backdrop.anm2", false)

        for num = 0, 15 do
            local wall_to_use = backdrop.Walls[StageAPI.Random(1, #backdrop.Walls, backdropRNG)]
            sprite:ReplaceSpritesheet(num, wall_to_use)
        end

        local nfloor_to_use = backdrop.NFloors[StageAPI.Random(1, #backdrop.NFloors, backdropRNG)]
        local lfloor_to_use = backdrop.LFloors[StageAPI.Random(1, #backdrop.LFloors, backdropRNG)]
        for num = 16, 17 do
            sprite:ReplaceSpritesheet(num, nfloor_to_use)
        end

        for num = 18, 22 do
            sprite:ReplaceSpritesheet(num, lfloor_to_use)
        end
        local corner_to_use = backdrop.Corners[StageAPI.Random(1, #backdrop.Corners, backdropRNG)]
        sprite:ReplaceSpritesheet(23, corner_to_use)

        sprite:LoadGraphics()

        local topLeft = room:GetTopLeftPos()
        local renderPos = topLeft + backdropDefaultOffset

        if roomShape == RoomShape.ROOMSHAPE_1x1 then sprite:Play("1x1_room", true)
        elseif roomShape ==  RoomShape.ROOMSHAPE_IH then sprite:Play("IH_room", true)
        elseif roomShape ==  RoomShape.ROOMSHAPE_IV then
            sprite:Play("IV_room", true)
            renderPos = topLeft + backdropIvOffset
        elseif roomShape ==  RoomShape.ROOMSHAPE_1x2 then sprite:Play("1x2_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_IIV then
            sprite:Play("IIV_room", true)
            renderPos = topLeft + backdropIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_2x1 then sprite:Play("2x1_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_IIH then sprite:Play("IIH_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_2x2 then sprite:Play("2x2_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LTL then sprite:Play("LTL_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LTR then sprite:Play("LTR_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LBL then sprite:Play("LBL_room", true)
        elseif roomShape == RoomShape.ROOMSHAPE_LBR then sprite:Play("LBR_room", true) end

        backdropEntity.Position = renderPos
        backdropEntity:AddEntityFlags(EntityFlag.FLAG_RENDER_WALL | EntityFlag.FLAG_RENDER_FLOOR)
    end

    local shadingDefaultOffset = Vector(-80,-80)
    local shadingIhOffset = Vector(-80,-160)
    local shadingIvOffset = Vector(-240,-80)
    function StageAPI.ChangeShading(name, prefix)
        prefix = prefix or "stageapi/shading/shading"
        local shading = Isaac.FindByType(StageAPI.E.Shading.T, StageAPI.E.Shading.V, -1, false, false)
        for _, e in ipairs(shading) do
            e:Remove()
        end

        local shadingEntity = Isaac.Spawn(StageAPI.E.Shading.T, StageAPI.E.Shading.V, 0, zeroVector, zeroVector, nil)
        local roomShape = room:GetRoomShape()

        local topLeft = room:GetTopLeftPos()
        local renderPos = topLeft + shadingDefaultOffset
        local sheet

        if roomShape == RoomShape.ROOMSHAPE_1x1 then sheet = ""
        elseif roomShape == RoomShape.ROOMSHAPE_1x2 then sheet = "_1x2"
        elseif roomShape == RoomShape.ROOMSHAPE_2x1 then sheet = "_2x1"
        elseif roomShape == RoomShape.ROOMSHAPE_2x2 then sheet = "_2x2"
        elseif roomShape == RoomShape.ROOMSHAPE_IH then
            sheet = "_ih"
            renderPos = topLeft + shadingIhOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IIH then
            sheet = "_iih"
            renderPos = topLeft + shadingIhOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IV then
            sheet = "_iv"
            renderPos = topLeft + shadingIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_IIV then
            sheet = "_iiv"
            renderPos = topLeft + shadingIvOffset
        elseif roomShape == RoomShape.ROOMSHAPE_LBL then sheet = "_lbl"
        elseif roomShape == RoomShape.ROOMSHAPE_LBR then sheet = "_lbr"
        elseif roomShape == RoomShape.ROOMSHAPE_LTL then sheet = "_ltl"
        elseif roomShape == RoomShape.ROOMSHAPE_LTR then sheet = "_ltr"
        end

        sheet = prefix .. sheet .. name .. ".png"

        local sprite = shadingEntity:GetSprite()
        sprite:Load("stageapi/Shading.anm2", false)
        sprite:ReplaceSpritesheet(0, sheet)
        sprite:LoadGraphics()
        sprite:Play("Default", true)

        shadingEntity.Position = renderPos
        shadingEntity:AddEntityFlags(EntityFlag.FLAG_DONT_OVERWRITE)
    end

    function StageAPI.ChangeRoomGfx(roomgfx)
        StageAPI.BackdropRNG:SetSeed(room:GetDecorationSeed(), 0)
        if #roomgfx.Backdrops > 0 then
            local backdrop = StageAPI.Random(1, #roomgfx.Backdrops, StageAPI.BackdropRNG)
            StageAPI.ChangeBackdrop(roomgfx.Backdrops[backdrop])
        else
            StageAPI.ChangeBackdrop(roomgfx.Backdrops)
        end

        StageAPI.ChangeGrids(roomgfx.Grids)
        StageAPI.ChangeShading(roomgfx.Shading.Name, roomgfx.Shading.Prefix)
    end

    StageAPI.RoomGfx = StageAPI.Class("RoomGfx")
    function StageAPI.RoomGfx:Init(backdrops, grids, shading, shadingPrefix)
        self.Backdrops = backdrops
        self.Grids = grids
        self.Shading = {
            Name = shading,
            Prefix = shadingPrefix
        }
    end
end

Isaac.DebugString("[StageAPI] Loading CustomStage Handler")
do -- Custom Stage
    StageAPI.CustomStages = {}

    StageAPI.CustomStage = StageAPI.Class("CustomStage")
    function StageAPI.CustomStage:Init(name, replaces, noSetReplaces)
        self.Name = name

        if not noSetReplaces then
            self.Replaces = replaces or StageAPI.StageOverride.CatacombsOne
        end

        if name then
            StageAPI.CustomStages[name] = self
        end
    end

    function StageAPI.CustomStage:SetName(name)
        self.Name = name or self.Name
        if self.Name then
            StageAPI.CustomStages[self.Name] = self
        end

    end

    function StageAPI.CustomStage:SetReplace(replaces)
        self.Replaces = replaces
    end

    function StageAPI.CustomStage:SetRoomGfx(gfx, rtype)
        if not self.RoomGfx then
            self.RoomGfx = {}
        end

        if type(rtype) == "table" then
            for _, roomtype in ipairs(rtype) do
                self.RoomGfx[roomtype] = gfx
            end
        else
            self.RoomGfx[rtype] = gfx
        end
    end

    function StageAPI.CustomStage:SetRooms(rooms)
        self.Rooms = rooms
    end

    function StageAPI.CustomStage:SetMusic(music, rtype)
        if not self.Music then
            self.Music = {}
        end

        if type(rtype) == "table" then
            for _, roomtype in ipairs(rtype) do
                self.Music[roomtype] = music
            end
        else
            self.Music[rtype] = music
        end
    end

    function StageAPI.CustomStage:SetBossMusic(music, clearedMusic)
        self.BossMusic = {
            Fight = music,
            Cleared = clearedMusic
        }
    end

    function StageAPI.CustomStage:SetSpots(bossSpot, playerSpot)
        self.BossSpot = bossSpot
        self.PlayerSpot = playerSpot
    end

    function StageAPI.CustomStage:SetBosses(bosses)
        for _, boss in ipairs(bosses) do
            if not boss.Shapes then
                boss.Shapes = {}
                for shape, rooms in pairs(boss.Rooms.ByShape) do
                    boss.Shapes[#boss.Shapes + 1] = shape
                end
            end

            if not boss.Weight then
                boss.Weight = 1
            end

            if boss.Horseman then
                bosses.HasHorseman = true
            end
        end

        self.Bosses = bosses
    end

    function StageAPI.CustomStage:GetPlayingMusic()
        local roomType = room:GetType()
        local id = StageAPI.Music:GetCurrentMusicID()
        if roomType == RoomType.ROOM_BOSS then
            local music = self.BossMusic
            local musicID
            if room:IsClear() then
                musicID = music.Cleared
            else
                musicID = music.Fight
            end

            if type(musicID) == "table" then
                StageAPI.MusicRNG:SetSeed(room:GetDecorationSeed(), 0)
                musicID = musicID[StageAPI.Random(1, #musicID, StageAPI.MusicRNG)]
            end

            if musicID and not StageAPI.IsIn(StageAPI.NonOverrideMusic, id) then
                return musicID, not room:IsClear()
            end
        else
            local music = self.Music
            local musicID = music[roomType]
            if musicID and not StageAPI.IsIn(StageAPI.NonOverrideMusic, id) then
                return musicID, not room:IsClear()
            end
        end
    end

    function StageAPI.CustomStage:IsStage()
        return StageAPI.CurrentStage and StageAPI.CurrentStage.Name == self.Name
    end
end

Isaac.DebugString("[StageAPI] Loading Stage Override Definitions")
do -- Definitions
    function StageAPI.BackdropHelper(backdrop, prefix, suffix)
        if #backdrop < 1 then
            backdrop = {backdrop}
        end

        for i, backdropVariant in ipairs(backdrop) do
            for k, backdropFiles in pairs(backdropVariant) do
                for i2, file in ipairs(backdropFiles) do
                    backdrop[i][k][i2] = prefix .. file .. suffix
                end
            end
        end

        return backdrop
    end

    StageAPI.CatacombsGridGfx = StageAPI.GridGfx()
    StageAPI.CatacombsGridGfx:SetRocks("gfx/grid/rocks_catacombs.png")
    StageAPI.CatacombsGridGfx:SetPits("gfx/grid/grid_pit_catacombs.png", "gfx/grid/grid_pit_water_catacombs.png")
    StageAPI.CatacombsGridGfx:SetBridges("gfx/grid/grid_bridge_catacombs.png")
    StageAPI.CatacombsGridGfx:SetDecorations("gfx/grid/props_03_caves.png")

    StageAPI.CatacombsBackdrop = {
        {
            Walls = {"Catacombs1_1", "Catacombs1_2"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs1_corner"}
        },
        {
            Walls = {"Catacombs2_1", "Catacombs2_2"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs2_corner"}
        }
    }

    StageAPI.CatacombsBackdrop = {
        {
            Walls = {"tombsand_1"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs1_corner"}
        },
        {
            Walls = {"tombtrap_1"},
            NFloors = {"Catacombs_nfloor"},
            LFloors = {"Catacombs_lfloor"},
            Corners = {"Catacombs2_corner"}
        }
    }

    StageAPI.CatacombsBackdrop = StageAPI.BackdropHelper(StageAPI.CatacombsBackdrop, "stageapi/backdrops/catacombs/", ".png")
    StageAPI.CatacombsRoomGfx = StageAPI.RoomGfx(StageAPI.CatacombsBackdrop, StageAPI.CatacombsGridGfx, "_default")
    StageAPI.CatacombsMusicID = Isaac.GetMusicIdByName("Catacombs")
    StageAPI.CatacombsRooms = StageAPI.RoomsList(require("catacombs"))
    StageAPI.Catacombs = StageAPI.CustomStage("Catacombs", nil, true)
    StageAPI.Catacombs:SetMusic(StageAPI.CatacombsMusicID, RoomType.ROOM_DEFAULT)
    StageAPI.Catacombs:SetBossMusic({Music.MUSIC_BOSS, Music.MUSIC_BOSS2}, Music.MUSIC_BOSS_OVER)
    StageAPI.Catacombs:SetRoomGfx(StageAPI.CatacombsRoomGfx, {RoomType.ROOM_DEFAULT, RoomType.ROOM_TREASURE, RoomType.ROOM_MINIBOSS, RoomType.ROOM_BOSS})
    StageAPI.Catacombs:SetRooms(StageAPI.CatacombsRooms)

    StageAPI.StageOverride = {
        CatacombsOne = {
            OverrideStage = LevelStage.STAGE2_1,
            OverrideStageType = StageType.STAGETYPE_WOTL,
            ReplaceWith = StageAPI.Catacombs
        },
        CatacombsTwo = {
            OverrideStage = LevelStage.STAGE2_2,
            OverrideStageType = StageType.STAGETYPE_WOTL,
            ReplaceWith = StageAPI.Catacombs
        }
    }

    StageAPI.Catacombs:SetReplace(StageAPI.StageOverride.CatacombsOne)

    function StageAPI.InOverriddenStage()
        for name, override in pairs(StageAPI.StageOverride) do
            local overridden = true

            local isStage = level:GetStage() == override.OverrideStage and level:GetStageType() == override.OverrideStageType
            if isStage then
                return true, override, name
            end
        end
    end

    StageAPI.NextStage = nil
    StageAPI.CurrentStage = nil

    function StageAPI.InNewStage()
        return StageAPI.CurrentStage and StageAPI.CurrentStage.Name ~= "Catacombs"
    end

    function StageAPI.GetCurrentStage()
        return StageAPI.CurrentStage
    end

    function StageAPI.GetCurrentListIndex()
        return level:GetCurrentRoomDesc().ListIndex
    end
end

Isaac.DebugString("[StageAPI] Loading Boss Handler")
do -- Bosses
    StageAPI.BossSpots = {
        [LevelStage.STAGE1_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "01_basement",
            [StageType.STAGETYPE_WOTL] = "02_cellar",
            [StageType.STAGETYPE_AFTERBIRTH] = "13_burning_basement",
            [StageType.STAGETYPE_GREEDMODE] = "01_basement"
        },
        [LevelStage.STAGE1_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "01_basement",
            [StageType.STAGETYPE_WOTL] = "02_cellar",
            [StageType.STAGETYPE_AFTERBIRTH] = "13_burning_basement",
            [StageType.STAGETYPE_GREEDMODE] = "01_basement"
        },
        [LevelStage.STAGE2_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "03_caves",
            [StageType.STAGETYPE_WOTL] = "04_catacombs",
            [StageType.STAGETYPE_AFTERBIRTH] = "14_drowned_caves",
            [StageType.STAGETYPE_GREEDMODE] = "03_caves"
        },
        [LevelStage.STAGE2_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "03_caves",
            [StageType.STAGETYPE_WOTL] = "04_catacombs",
            [StageType.STAGETYPE_AFTERBIRTH] = "14_drowned_caves",
            [StageType.STAGETYPE_GREEDMODE] = "03_caves"
        },
        [LevelStage.STAGE3_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "05_depths",
            [StageType.STAGETYPE_WOTL] = "06_necropolis",
            [StageType.STAGETYPE_AFTERBIRTH] = "15_dank_depths",
            [StageType.STAGETYPE_GREEDMODE] = "05_depths"
        },
        [LevelStage.STAGE3_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "05_depths",
            [StageType.STAGETYPE_WOTL] = "06_necropolis",
            [StageType.STAGETYPE_AFTERBIRTH] = "15_dank_depths",
            [StageType.STAGETYPE_GREEDMODE] = "05_depths"
        },
        [LevelStage.STAGE4_1] = {
            [StageType.STAGETYPE_ORIGINAL] = "07_womb",
            [StageType.STAGETYPE_WOTL] = "07_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "16_scarred_womb",
            [StageType.STAGETYPE_GREEDMODE] = "07_womb"
        },
        [LevelStage.STAGE4_2] = {
            [StageType.STAGETYPE_ORIGINAL] = "07_womb",
            [StageType.STAGETYPE_WOTL] = "07_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "16_scarred_womb",
            [StageType.STAGETYPE_GREEDMODE] = "07_womb"
        },
        [LevelStage.STAGE4_3] = {
            [StageType.STAGETYPE_ORIGINAL] = "17_blue_womb",
            [StageType.STAGETYPE_WOTL] = "17_blue_womb",
            [StageType.STAGETYPE_AFTERBIRTH] = "17_blue_womb",
            [StageType.STAGETYPE_GREEDMODE] = "17_blue_womb"
        },
        [LevelStage.STAGE5] = {
            [StageType.STAGETYPE_ORIGINAL] = "09_sheol",
            [StageType.STAGETYPE_WOTL] = "10_cathedral",
            [StageType.STAGETYPE_AFTERBIRTH] = "09_sheol",
            [StageType.STAGETYPE_GREEDMODE] = "09_sheol"
        },
        [LevelStage.STAGE6] = {
            [StageType.STAGETYPE_ORIGINAL] = "11_darkroom",
            [StageType.STAGETYPE_WOTL] = "12_chest",
            [StageType.STAGETYPE_AFTERBIRTH] = "11_darkroom",
            [StageType.STAGETYPE_GREEDMODE] = "18_shop"
        },
        [LevelStage.STAGE7] = {
            [StageType.STAGETYPE_ORIGINAL] = "19_void",
            [StageType.STAGETYPE_WOTL] = "19_void",
            [StageType.STAGETYPE_AFTERBIRTH] = "19_void",
            [StageType.STAGETYPE_GREEDMODE] = "18_shop"
        }
    }

    StageAPI.PlayerBossInfo = {
        isaac = "01",
        magdalene = "02",
        cain = "03",
        judas = "04",
        eve = "05",
        ["???"] = "06",
        samson = "07",
        azazel = "08",
        eden = "09",
        thelost = "12",
        lilith = "13",
        keeper = "14",
        apollyon = "15"
    }

    for k, v in pairs(StageAPI.PlayerBossInfo) do
        local use = k
        if k == "???" then
            use = "bluebaby"
        end

        StageAPI.PlayerBossInfo[k] = {
            Portrait = "gfx/ui/boss/playerportrait_" .. v .. "_" .. use .. ".png",
            Name = "gfx/ui/boss/playername_" .. v .. "_" .. use .. ".png"
        }
    end

    function StageAPI.AddPlayerBossInfo(name, portrait, namefile)
        StageAPI.PlayerBossInfo[string.gsub(string.lower(name), "%s+", "")] = {
            Portrait = portrait,
            Name = namefile
        }
    end

    StageAPI.AddPlayerBossInfo("Black Judas", "gfx/ui/boss/playerportrait_blackjudas.png", "gfx/ui/boss/playername_04_judas.png")
    StageAPI.AddPlayerBossInfo("Lazarus", "gfx/ui/boss/playerportrait_09_lazarus.png", "gfx/ui/boss/playername_10_lazarus.png")
    StageAPI.AddPlayerBossInfo("Lazarus 2", "gfx/ui/boss/playerportrait_10_lazarus2.png", "gfx/ui/boss/playername_10_lazarus.png")

    function StageAPI.GetStageSpot()
        if StageAPI.InNewStage() then
            return StageAPI.CurrentStage.BossSpot or "gfx/ui/boss/bossspot.png", StageAPI.CurrentStage.PlayerSpot or "gfx/ui/boss/playerspot.png"
        else
            local stage, stype = level:GetStage(), level:GetStageType()
            local spot = StageAPI.BossSpots[stage][stype]
            return "gfx/ui/boss/bossspot_" .. spot .. ".png", "gfx/ui/boss/playerspot_" .. spot .. ".png"
        end
    end

    function StageAPI.TryGetPlayerBossInfo(player)
        local playerName = string.gsub(string.lower(player:GetName()), "%s+", "")
        if StageAPI.PlayerBossInfo[playerName] then
            return StageAPI.PlayerBossInfo[playerName].Portrait, StageAPI.PlayerBossInfo[playerName].Name
        else -- worth a shot, most common naming convention
            return "gfx/ui/boss/playerportrait_" .. playerName .. ".png", "gfx/ui/boss/playername_" .. playerName .. ".png"
        end
    end

    StageAPI.BossSprite = Sprite()
    StageAPI.BossSprite:Load("gfx/ui/boss/versusscreen.anm2", false)
    function StageAPI.PlayBossAnimationManual(portrait, name, spot, playerPortrait, playerName, playerSpot, portraitTwo)
        spot = spot or "gfx/ui/boss/bossspot.png"
        name = name or "gfx/ui/boss/bossname_20.0_monstro.png"
        portrait = portrait or "gfx/ui/boss/portrait_20.0_monstro.png"
        playerSpot = playerSpot or "gfx/ui/boss/bossspot.png"
        playerName = playerName or "gfx/ui/boss/bossname_20.0_monstro.png"
        playerPortrait = playerPortrait or "gfx/ui/boss/portrait_20.0_monstro.png"

        StageAPI.BossSprite:ReplaceSpritesheet(2, spot)
        StageAPI.BossSprite:ReplaceSpritesheet(3, playerSpot)
        StageAPI.BossSprite:ReplaceSpritesheet(4, portrait)
        StageAPI.BossSprite:ReplaceSpritesheet(5, playerPortrait)
        StageAPI.BossSprite:ReplaceSpritesheet(6, playerName)
        StageAPI.BossSprite:ReplaceSpritesheet(7, name)

        if portraitTwo then
            StageAPI.BossSprite:ReplaceSpritesheet(9, portraitTwo)
            StageAPI.BossSprite:Play("DoubleTrouble", true)
        else
            StageAPI.BossSprite:Play("Scene", true)
        end

        StageAPI.BossSprite:LoadGraphics()
    end

    StageAPI.IsOddRenderFrame = nil
    mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
        StageAPI.IsOddRenderFrame = not StageAPI.IsOddRenderFrame
        if StageAPI.BossSprite:IsPlaying("Scene") or StageAPI.BossSprite:IsPlaying("DoubleTrouble") then
            if StageAPI.IsOddRenderFrame then
                StageAPI.BossSprite:Update()
            end

            if Input.IsActionTriggered(ButtonAction.ACTION_MENUCONFIRM, StageAPI.Players[1].ControllerIndex) then
                StageAPI.BossSprite:Stop()
            else
                StageAPI.BossSprite:Render(StageAPI.GetScreenCenterPosition(), zeroVector, zeroVector)
            end
        end
    end)

    StageAPI.DummyBoss = {}
    function StageAPI.PlayBossAnimation(boss)
        local bSpot, pSpot = StageAPI.GetStageSpot()
        local playerPortrait, playerName = StageAPI.TryGetPlayerBossInfo(StageAPI.Players[1])
        StageAPI.PlayBossAnimationManual(boss.Portrait, boss.Bossname, boss.Spot or bSpot, playerPortrait, playerName, pSpot, boss.PortraitTwo)
    end

    local horsemanTypes = {
        EntityType.ENTITY_WAR,
        EntityType.ENTITY_FAMINE,
        EntityType.ENTITY_DEATH,
        EntityType.ENTITY_HEADLESS_HORSEMAN,
        EntityType.ENTITY_PESTILENCE
    }

    StageAPI.EncounteredBosses = {}
    function StageAPI.SetBossEncountered(name, encountered)
        if encountered == nil then
            encountered = true
        end

        StageAPI.EncounteredBosses[name] = encountered
    end

    function StageAPI.GetBossEncountered(name)
        return StageAPI.EncounteredBosses[name]
    end

    mod:AddCallback(ModCallbacks.MC_POST_GAME_STARTED, function(_, continued)
        if not continued then
            StageAPI.EncounteredBosses = {}
        end
    end)

    StageAPI.BossSelectRNG = RNG()
    function StageAPI.SelectBoss(bosses, allowHorseman, rng)
        local boss = StageAPI.CallCallbacks("PRE_BOSS_SELECT", true, bosses, allowHorseman, rng)
        if not boss then
            local forceHorseman = false
            if allowHorseman then
                for _, t in ipairs(horsemanTypes) do
                    if #Isaac.FindByType(t, -1, -1, false, false) > 0 then
                        forceHorseman = true
                    end
                end
            end

            local totalUnencounteredWeight = 0
            local totalValidWeight = 0
            local unencounteredBosses = {}
            local validBosses = {}
            for _, potentialBoss in ipairs(bosses) do
                if StageAPI.IsIn(potentialBoss.Shapes, room:GetRoomShape()) then
                    local encountered = StageAPI.GetBossEncountered(potentialBoss.Name)
                    if not encountered and potentialBoss.NameTwo then
                        encountered = StageAPI.GetBossEncountered(potentialBoss.NameTwo)
                    end

                    local weight = potentialBoss.Weight
                    if not encountered then
                        totalUnencounteredWeight = totalUnencounteredWeight + weight
                        unencounteredBosses[#unencounteredBosses + 1] = {potentialBoss, weight}
                    end

                    totalValidWeight = totalValidWeight + weight
                    validBosses[#validBosses + 1] = {potentialBoss, weight}
                end
            end

            if not rng then
                rng = StageAPI.BossSelectRNG
                rng:SetSeed(room:GetSpawnSeed(), 0)
            end

            if #unencounteredBosses > 0 then
                boss = StageAPI.WeightedRNG(unencounteredBosses, rng, nil, totalUnencounteredWeight)
            elseif #validBosses > 0 then
                boss = StageAPI.WeightedRNG(validBosses, rng, nil, totalValidWeight)
            end
        end

        return boss
    end
end

Isaac.DebugString("[StageAPI] Loading Transition Handler")
do -- Transition
    StageAPI.StageTypeToString = {
        [StageType.STAGETYPE_ORIGINAL] = "",
        [StageType.STAGETYPE_WOTL] = "a",
        [StageType.STAGETYPE_AFTERBIRTH] = "b"
    }

    function StageAPI.GotoCustomStage(stage)
        local replace = stage.Replaces
        local absolute = replace.OverrideStage
        StageAPI.NextStage = stage
        Isaac.ExecuteCommand("stage " .. tostring(absolute) .. StageAPI.StageTypeToString[replace.OverrideStageType])
    end
end

Isaac.DebugString("[StageAPI] Loading Core Callbacks")
do -- Callbacks
    StageAPI.NonOverrideMusic = {
        Music.MUSIC_GAME_OVER,
        Music.MUSIC_JINGLE_SECRETROOM_FIND,
        Music.MUSIC_JINGLE_NIGHTMARE,
        Music.MUSIC_JINGLE_GAME_START,
        Music.MUSIC_JINGLE_BOSS,
        Music.MUSIC_JINGLE_BOSS_OVER,
        Music.MUSIC_JINGLE_BOSS_OVER2,
        Music.MUSIC_JINGLE_DEVILROOM_FIND,
        Music.MUSIC_JINGLE_HOLYROOM_FIND
    }

    function StageAPI.StopOverridingMusic(music)
        StageAPI.NonOverrideMusic[#StageAPI.NonOverrideMusic + 1] = music
    end

    mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
        local currentRoom = StageAPI.GetCurrentRoom()
        if currentRoom then
            currentRoom.IsClear = room:IsClear()
        end
    end)

    StageAPI.RoomGrids = {}

    function StageAPI.PreventRoomGridRegrowth()
        StageAPI.RoomGrids[StageAPI.GetCurrentListIndex()] = {}
    end

    function StageAPI.StoreRoomGrids()
        local roomIndex = StageAPI.GetCurrentListIndex()
        local grids = {}
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid and grid.Desc.Type ~= GridEntityType.GRID_WALL and grid.Desc.Type ~= GridEntityType.GRID_DOOR then
                grids[i] = true
            end
        end

        StageAPI.RoomGrids[roomIndex] = grids
    end

    function StageAPI.RemoveExtraGrids(grids)
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid and grid.Desc.Type ~= GridEntityType.GRID_WALL and grid.Desc.Type ~= GridEntityType.GRID_DOOR and not grids[i] then
                room:RemoveGridEntity(i, 0, true)
            end
        end

        room:Update()
    end

    mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, function()
        StageAPI.RoomGrids = {}
    end)

    StageAPI.RoomNamesEnabled = false
    StageAPI.OldBackdropType = nil
    StageAPI.PreviousGridCount = nil

    function StageAPI.ReprocessRoomGrids()
        StageAPI.PreviousGridCount = nil
    end

    mod:AddCallback(ModCallbacks.MC_PRE_USE_ITEM, StageAPI.ReprocessRoomGrids, CollectibleType.COLLECTIBLE_D12)

    StageAPI.OverridenD7 = Isaac.GetItemIdByName("D7 ")
    StageAPI.JustUsedD7 = nil

    function StageAPI.UseD7()
        local currentRoom = StageAPI.GetCurrentRoom()
        if currentRoom then
            StageAPI.JustUsedD7 = true
        else
            players[1]:UseActiveItem(CollectibleType.COLLECTIBLE_D7, true, true, true, false)
        end

        return true
    end

    mod:AddCallback(ModCallbacks.MC_USE_ITEM, StageAPI.UseD7, StageAPI.OverridenD7)

    mod:AddCallback(ModCallbacks.MC_PRE_ENTITY_SPAWN, function(_, t, v, s, po, ve, sp, se)
        if t == EntityType.ENTITY_PICKUP and v == PickupVariant.PICKUP_COLLECTIBLE and s == CollectibleType.COLLECTIBLE_D7 then
            return {t, v, StageAPI.OverridenD7, se}
        end
    end)

    mod:AddCallback(ModCallbacks.MC_POST_UPDATE, function()
        if StageAPI.JustUsedD7 then
            StageAPI.JustUsedD7 = nil
            local currentRoom = StageAPI.GetCurrentRoom()
            if currentRoom then
                currentRoom.IsClear = currentRoom.WasClearAtStart
                currentRoom:Load()
            end
        end
    end)

    StageAPI.Music = MusicManager()
    StageAPI.MusicRNG = RNG()
    mod:AddCallback(ModCallbacks.MC_POST_RENDER, function()
        local currentListIndex = StageAPI.GetCurrentListIndex()
        local stage = level:GetStage()
        local stype = level:GetStageType()

        local updatedGrids
        local gridCount = 0
        local pits = {}
        for i = 0, room:GetGridSize() do
            local grid = room:GetGridEntity(i)
            if grid then
                if grid.Desc.Type == GridEntityType.GRID_PIT then
                    pits[#pits + 1] = grid

                end

                gridCount = gridCount + 1
            end
        end

        if gridCount ~= StageAPI.PreviousGridCount then
            updatedGrids = true
            if StageAPI.RoomGrids[roomIndex] then
                StageAPI.StoreRoomGrids()
            end

            StageAPI.PreviousGridCount = gridCount
        end

        if StageAPI.InOverriddenStage() then
            if StageAPI.CurrentStage then
                local roomType = room:GetType()
                local rtype
                local currentRoom = StageAPI.LevelRooms[currentListIndex]
                if currentRoom and currentRoom.RoomType then
                    rtype = currentRoom.RoomType
                else
                    rtype = roomType
                end

                local grids
                local gridsOverride
                local callbacks = StageAPI.GetCallbacks("PRE_UPDATE_GRID_GFX")
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function()
                    if ret then
                        gridsOverride = ret
                    end
                end

                if not gridsOverride and StageAPI.CurrentStage.RoomGfx and StageAPI.CurrentStage.RoomGfx[rtype] and StageAPI.CurrentStage.RoomGfx[rtype].Grids then
                    grids = StageAPI.CurrentStage.RoomGfx[rtype].Grids
                elseif gridsOverride then
                    grids = gridsOverride
                end

                if grids then
                    if grids.Bridges then
                        for _, grid in ipairs(pits) do
                            StageAPI.CheckBridge(grid, i, grids.Bridges)
                        end
                    end

                    if updatedGrids then
                        StageAPI.ChangeGrids(grids)
                    end
                end

                local id = StageAPI.Music:GetCurrentMusicID()
                local musicID, shouldLayer = StageAPI.CurrentStage:GetPlayingMusic()
                if musicID then
                    StageAPI.Music:Queue(musicID)
                    StageAPI.Music:UpdateVolume()
                    if id ~= musicID then
                        StageAPI.Music:Play(musicID, 0.1)
                        StageAPI.Music:UpdateVolume()
                    end

                    if shouldLayer and not StageAPI.Music:IsLayerEnabled() then
                        StageAPI.Music:EnableLayer()
                    elseif not shouldLayer and StageAPI.Music:IsLayerEnabled() then
                        StageAPI.Music:DisableLayer()
                    end
                end
            end
        end

        local btype = room:GetBackdropType()
        if StageAPI.OldBackdropType ~= btype then
            if btype == 5 and not StageAPI.InOverriddenStage() then
                StageAPI.ChangeRoomGfx(StageAPI.CatacombsRoomGfx)
            end

            StageAPI.OldBackdropType = btype
        end

        for _, player in ipairs(players) do
            if player:HasCollectible(CollectibleType.COLLECTIBLE_D7) then
                player:RemoveCollectible(CollectibleType.COLLECTIBLE_D7)
                player:AddCollectible(StageAPI.OverridenD7, player:GetActiveCharge(), false)
            end

            if Input.IsButtonTriggered(Keyboard.KEY_F5, player.ControllerIndex) then
                StageAPI.RoomNamesEnabled = not StageAPI.RoomNamesEnabled
            end
        end

        if StageAPI.RoomNamesEnabled then
            local currentRoom = StageAPI.LevelRooms[currentListIndex]
            if currentRoom and currentRoom.RoomFilename and currentRoom.Name and currentRoom.Variant then
                Isaac.RenderText("Room File: " .. currentRoom.RoomFilename .. ", Name: " .. currentRoom.Name .. ", ID: " .. tostring(currentRoom.Variant), 60, 35, 255, 255, 255, 1)
            end
        end
    end)

    mod:AddCallback(ModCallbacks.MC_POST_NEW_ROOM, function()
        local stage = level:GetStage()
        local stype = level:GetStageType()
        local isNewStage, override = StageAPI.InOverriddenStage()
        local currentListIndex = StageAPI.GetCurrentListIndex()

        if StageAPI.RoomGrids[currentListIndex] then
            StageAPI.RemoveExtraGrids(StageAPI.RoomGrids[currentListIndex])
        end

        if isNewStage then

            local currentRoom = StageAPI.GetCurrentRoom()
            if level:GetCurrentRoomIndex() == level:GetStartingRoomIndex() then
                if room:IsFirstVisit() then
                    currentRoom = nil
                    StageAPI.LevelRooms = {}
                    if not StageAPI.NextStage then
                        StageAPI.CurrentStage = override.ReplaceWith
                    else
                        StageAPI.CurrentStage = StageAPI.NextStage
                    end

                    for _, player in ipairs(StageAPI.Players) do
                        player.Position = room:GetCenterPos()
                        player:AnimateAppear()
                        player.ControlsCooldown = 80
                    end

                    StageAPI.NextStage = nil
                end
            else
                if StageAPI.CurrentStage and room:GetType() == RoomType.ROOM_DEFAULT then
                    if not currentRoom then
                        local newRoom = StageAPI.LevelRoom(nil, StageAPI.CurrentStage.Rooms.ByShape)
                        newRoom:Load()
                        currentRoom = newRoom
                        StageAPI.SetCurrentRoom(newRoom)
                        StageAPI.CallCallbacks("POST_GENERATE_ROOM", false, currentRoom, false)
                    else
                        currentRoom:Load()
                        StageAPI.CallCallbacks("POST_GENERATE_ROOM", false, currentRoom, true)
                    end
                end
            end

            if StageAPI.InNewStage() and room:GetType() == RoomType.ROOM_BOSS and StageAPI.CurrentStage.Bosses then
                if not room:IsClear() then
                    local boss = StageAPI.SelectBoss(StageAPI.CurrentStage.Bosses, StageAPI.CurrentStage.Bosses.HasHorseman)
                    StageAPI.SetBossEncountered(boss.Name)
                    if boss.NameTwo then
                        StageAPI.SetBossEncountered(boss.NameTwo)
                    end

                    local newRoom = StageAPI.LevelRoom(nil, boss.Rooms.ByShape)
                    newRoom:Load()

                    currentRoom = newRoom
                    StageAPI.SetCurrentRoom(newRoom)
                    StageAPI.CallCallbacks("POST_GENERATE_ROOM", false, currentRoom, false)

                    StageAPI.PlayBossAnimation(boss)
                end
            end

            local rtype
            if currentRoom and currentRoom.RoomType then
                rtype = currentRoom.RoomType
            else
                rtype = room:GetType()
            end

            if StageAPI.CurrentStage.RoomGfx[rtype] then
                local callbacks = StageAPI.GetCallbacks("PRE_CHANGE_ROOM_GFX")
                local gfxOverride
                for _, callback in ipairs(callbacks) do
                    local ret = callback.Function()
                    if ret ~= nil then
                        gfxOverride = ret
                    end
                end

                if gfxOverride == nil then
                    StageAPI.ChangeRoomGfx(StageAPI.CurrentStage.RoomGfx[rtype])
                elseif gfxOverride ~= false then
                    StageAPI.ChangeRoomGfx(gfxOverride)
                end

                local callbacks = StageAPI.GetCallbacks("POST_CHANGE_ROOM_GFX")
                for _, callback in ipairs(callbacks) do
                    callback.Function()
                end
            else
                StageAPI.ChangeShading("_default")
            end
        else
            if room:GetBackdropType() == 5 then
                StageAPI.ChangeRoomGfx(StageAPI.CatacombsRoomGfx)
                StageAPI.OldBackdropType = 5
            end

            StageAPI.ChangeShading("_default")
        end
    end)

    mod:AddCallback(ModCallbacks.MC_EXECUTE_CMD, function(_, cmd, params)
        if (cmd == "cstage" or cmd == "customstage") and StageAPI.CustomStages[params] then
            if StageAPI.CustomStages[params] then
                StageAPI.GotoCustomStage(StageAPI.CustomStages[params])
            else
                Isaac.ConsoleOutput("No CustomStage " .. params)
            end
        elseif cmd == "regrowthtest" then
            StageAPI.ClearRoomLayout(false, true, true)
            StageAPI.StoreRoomGrids()
        elseif cmd == "reload" then
            StageAPI.RoomGrids, StageAPI.LevelRooms = StageAPI.LoadSaveString(StageAPI.GetSaveString())
        elseif cmd == "printsave" then
            Isaac.DebugString(StageAPI.GetSaveString())
        end
    end)
end

Isaac.DebugString("[StageAPI] Loading Save System")
do
    local json = require("json")
    function StageAPI.GetSaveString()
        local saveData = {}
        for index, roomGrids in pairs(StageAPI.RoomGrids) do
            local strindex = tostring(index)
            if not saveData[strindex] then
                saveData[strindex] = {
                    Grids = {},
                    AvoidSpawning = {},
                    ExtraSpawn = {},
                    PersistentPositions = {}
                }
            end

            for grindex, exists in pairs(roomGrids) do
                if exists then
                    saveData[strindex].Grids[#saveData[strindex].Grids + 1] = grindex
                end
            end
        end

        for index, roomLayout in pairs(StageAPI.LevelRooms) do
            local strindex = tostring(index)
            if not saveData[strindex] then
                saveData[strindex] = {
                    Grids = {},
                    AvoidSpawning = {},
                    ExtraSpawn = {},
                    PersistentPositions = {}
                }
            end

            saveData[strindex].IsClear = roomLayout.IsClear
            saveData[strindex].WasClearAtStart = roomLayout.WasClearAtStart
            saveData[strindex].RoomsListName = roomLayout.RoomsListName
            saveData[strindex].Seed = roomLayout.Seed
            saveData[strindex].FirstLoad = roomLayout.FirstLoad
            saveData[strindex].Shape = roomLayout.Shape
            saveData[strindex].Type = roomLayout.Type

            for index, avoid in pairs(roomLayout.AvoidSpawning) do
                if avoid then
                    saveData[strindex].AvoidSpawning[#saveData[strindex].AvoidSpawning + 1] = index
                end
            end

            for pindex, position in pairs(roomLayout.PersistentPositions) do
                saveData[strindex].PersistentPositions[tostring(pindex)] = position
            end

            for index, entity in pairs(roomLayout.ExtraSpawn) do
                saveData[strindex].ExtraSpawn[tostring(index)] = entity
            end
        end

        for index, roomSaveData in pairs(saveData) do
            for k, v in pairs(roomSaveData) do
                if type(v) == "table" and #v == 0 then
                    roomSaveData[k] = nil
                end
            end
        end

        return json.encode(saveData)
    end

    function StageAPI.LoadSaveString(str)
        local retLevelRooms = {}
        local retRoomGrids = {}
        local decoded = json.decode(str)
        for strindex, roomSaveData in pairs(decoded) do
            local lindex = tonumber(strindex)
            if roomSaveData.Grids then
                retRoomGrids[lindex] = {}
                for _, grindex in ipairs(roomSaveData.Grids) do
                    retRoomGrids[lindex][grindex] = true
                end
            end

            if roomSaveData.RoomsListName and roomSaveData.Seed and roomSaveData.Shape and roomSaveData.Type then
                local roomLayout = StageAPI.LevelRoom(nil, StageAPI.RoomsLists[roomSaveData.RoomsListName], roomSaveData.Seed, roomSaveData.Shape, roomSaveData.Type)
                if roomSaveData.ExtraSpawn then
                    if not roomLayout.ExtraSpawn then
                        roomLayout.ExtraSpawn = {}
                    end

                    for strgrindex, entity in pairs(roomSaveData.ExtraSpawn) do
                        roomLayout.ExtraSpawn[tonumber(strgrindex)] = entity
                    end
                end

                if roomSaveData.AvoidSpawning then
                    if not roomLayout.AvoidSpawning then
                        roomLayout.AvoidSpawning = {}
                    end

                    for _, pindex in ipairs(roomSaveData.AvoidSpawning) do
                        roomLayout.AvoidSpawning[pindex] = true
                    end
                end

                if roomSaveData.PersistentPositions then
                    if not roomLayout.PersistentPositions then
                        roomLayout.PersistentPositions = {}
                    end

                    for strpindex, position in pairs(roomSaveData.PersistentPositions) do
                        roomLayout.PersistentPositions[tonumber(strpindex)] = position
                    end
                end

                retLevelRooms[lindex] = roomLayout
            end
        end

        return retRoomGrids, retLevelRooms
    end
end

Isaac.DebugString("[StageAPI] Fully Loaded, loading dependent mods.")

StageAPI.Loaded = true
if StageAPI.ToCall then
    for _, fn in ipairs(StageAPI.ToCall) do
        fn()
    end
end
